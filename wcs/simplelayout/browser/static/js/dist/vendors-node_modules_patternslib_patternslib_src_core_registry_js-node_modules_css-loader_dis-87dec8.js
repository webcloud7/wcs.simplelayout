"use strict";
(self["webpackChunksimplelayout"] = self["webpackChunksimplelayout"] || []).push([["vendors-node_modules_patternslib_patternslib_src_core_registry_js-node_modules_css-loader_dis-87dec8"],{

/***/ "./node_modules/@patternslib/patternslib/src/core/dom.js":
/*!***************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/dom.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ "./node_modules/@patternslib/patternslib/src/core/events.js");
/* Utilities for DOM traversal or navigation */


const DATA_PREFIX = "__patternslib__data_prefix__";
const DATA_STYLE_DISPLAY = "__patternslib__style__display";

const toNodeArray = (nodes) => {
    // Return an array of DOM nodes
    if (nodes.jquery || nodes instanceof NodeList) {
        // jQuery or document.querySelectorAll
        nodes = [...nodes];
    } else if (nodes instanceof Array === false) {
        nodes = [nodes];
    }
    return nodes;
};

const querySelectorAllAndMe = (el, selector) => {
    // Like querySelectorAll but including the element where it starts from.
    // Returns an Array, not a NodeList

    if (!el) {
        return [];
    }

    const all = [...el.querySelectorAll(selector)];
    if (el.matches(selector)) {
        all.unshift(el); // start element should be first.
    }
    return all;
};

const wrap = (el, wrapper) => {
    // Wrap a element with a wrapper element.
    // See: https://stackoverflow.com/a/13169465/1337474

    el.parentNode.insertBefore(wrapper, el);
    wrapper.appendChild(el);
};

const hide = (el) => {
    // Hides the element with ``display: none``
    if (el.style.display === "none") {
        // Nothing to do.
        return;
    }
    if (el.style.display) {
        el[DATA_STYLE_DISPLAY] = el.style.display;
    }
    el.style.display = "none";
    el.setAttribute("hidden", "");
};

const show = (el) => {
    // Shows element by removing ``display: none`` and restoring the display
    // value to whatever it was before.
    const val = el[DATA_STYLE_DISPLAY] || null;
    el.style.display = val;
    delete el[DATA_STYLE_DISPLAY];
    el.removeAttribute("hidden", "");
};

const find_parents = (el, selector) => {
    // Return all direct parents of ``el`` matching ``selector``.
    // This matches against all parents but not the element itself.
    // The order of elements is from the search starting point up to higher
    // DOM levels.
    const ret = [];
    let parent = el?.parentNode?.closest?.(selector);
    while (parent) {
        ret.push(parent);
        parent = parent.parentNode?.closest?.(selector);
    }
    return ret;
};

const find_scoped = (el, selector) => {
    // If the selector starts with an object id do a global search,
    // otherwise do a local search.
    return (selector.indexOf("#") === 0 ? document : el).querySelectorAll(selector);
};

const get_parents = (el) => {
    // Return all HTMLElement parents of el, starting from the direct parent of el.
    // The document itself is excluded because it's not a real DOM node.
    const parents = [];
    let parent = el?.parentNode;
    while (parent) {
        parents.push(parent);
        parent = parent?.parentNode;
        parent = parent instanceof HTMLElement ? parent : null;
    }
    return parents;
};

/**
 * Return the value of the first attribute found in the list of parents.
 *
 * @param {DOM element} el - The DOM element to start the acquisition search for the given attribute.
 * @param {string} attribute - Name of the attribute to search for.
 * @param {Boolean} include_empty - Also return empty values.
 * @param {Boolean} include_all - Return a list of attribute values found in all parents.
 *
 * @returns {*} - Returns the value of the searched attribute or a list of all attributes.
 */
const acquire_attribute = (
    el,
    attribute,
    include_empty = false,
    include_all = false
) => {
    let _el = el;
    const ret = []; // array for ``include_all`` mode.
    while (_el) {
        const val = _el.getAttribute(attribute);
        if (val || (include_empty && val === "")) {
            if (!include_all) {
                return val;
            }
            ret.push(val);
        }
        _el = _el.parentElement;
    }
    if (include_all) {
        return ret;
    }
};

const is_visible = (el) => {
    // Check, if element is visible in DOM.
    // https://stackoverflow.com/a/19808107/1337474
    return el.offsetWidth > 0 && el.offsetHeight > 0;
};

/**
 * Return a DocumentFragment from a given string.
 *
 * @param {String} string - The HTML structure as a string.
 *
 * @returns {DocumentFragment} - The DOM nodes as a DocumentFragment.
 */
const create_from_string = (string) => {
    // See: https://davidwalsh.name/convert-html-stings-dom-nodes
    return document.createRange().createContextualFragment(string.trim());
};

/**
 * Return a CSS property value for a given DOM node.
 * For length-values, relative values are converted to pixels.
 * Optionally parse as pixels, if applicable.
 *
 * Note: The element must be attached to the body to make CSS caluclations work.
 *
 * @param {Node} el - DOM node.
 * @param {String} property - CSS property to query on DOM node.
 * @param {Boolean} [as_pixels=false] - Convert value to pixels, if applicable.
 * @param {Boolean} [as_float=false] - Convert value to float, if applicable.
 *
 * @returns {(String|Number)} - The CSS value to return.
 */
function get_css_value(el, property, as_pixels = false, as_float = false) {
    let value = window.getComputedStyle(el).getPropertyValue(property);
    if (as_pixels || as_float) {
        value = parseFloat(value) || 0.0;
    }
    if (as_pixels && !as_float) {
        value = parseInt(Math.round(value), 10);
    }
    return value;
}

/**
 * Find a scrollable element up in the DOM tree.
 *
 * Note: Setting the ``overflow`` shorthand property also sets the individual overflow-y and overflow-y properties.
 *
 * @param {Node} el - The DOM element to start the search on.
 * @param {String} [direction=] - Not given: Search for any scrollable element up in the DOM tree.
 *                                ``x``: Search for a horizontally scrollable element.
 *                                ``y``: Search for a vertically scrollable element.
 * @param {(DOM Node|null)} [fallback=document.body] - Fallback, if no scroll container can be found.
 *                                                     The default is to use document.body.
 *
 * @returns {Node} - Return the first scrollable element.
 *                   If no other element could be found, document.body would be returned.
 */
const find_scroll_container = (el, direction, fallback = document.body) => {
    while (el && el !== document.body) {
        if (!direction || direction === "y") {
            let overflow_y = get_css_value(el, "overflow-y");
            if (["auto", "scroll"].includes(overflow_y)) {
                return el;
            }
        }
        if (!direction || direction === "x") {
            let overflow_x = get_css_value(el, "overflow-x");
            if (["auto", "scroll"].includes(overflow_x)) {
                return el;
            }
        }
        el = el.parentElement;
    }
    return fallback;
};

/**
 * Get data stored directly on the node instance.
 * We are using a prefix to make sure the data doesn't collide with other attributes.
 *
 * @param el {Node} - The DOM node from which we want to retrieve the data.
 * @param name {String} - The name of the variable. Note - this is stored on
 *                        the DOM node prefixed with the DATA_PREFIX.
 * @param default_value {Any} - Optional default value.
 * @return {Any} - The value which is stored on the DOM node.
 */
const get_data = (el, name, default_value) => {
    return el[`${DATA_PREFIX}${name}`] || default_value;
};

/**
 * Set and store data directly on the node instance.
 * We are using a prefix to make sure the data doesn't collide with other attributes.
 *
 * @param el {Node} - The DOM node which we want to store the data on.
 * @param name {String} - The name of the variable. Note - this is stored on
 *                        the DOM node prefixed with the DATA_PREFIX.
 * @param value {Any} - The value we want to store on the DOM node.
 */
const set_data = (el, name, value) => {
    el[`${DATA_PREFIX}${name}`] = value;
};

/**
 * Simple template engine, based on JS template literal
 *
 * Please note: You cannot pass a template literal as template_string.
 * JavaScript itself would try to expand it and would fail.
 *
 * See: https://stackoverflow.com/a/37217166/1337474
 *
 * @param {String} template_string - The template string as a JavaScript template literal.
 *                                   For each variable in the template you have to use ``this``.
 *                                   E.g. if you pass ``{message: "ok"}`` as template_variables, you can use it like so:
 *                                   `<h1>${this.message}</h1>`
 * @param {Object} template_variables - Object literal with all the variables which should be used in the template.
 *
 * @returns {String} - Returns the a string as template expanded with the template_variables.
 */
const template = (template_string, template_variables = {}) => {
    return new Function("return `" + template_string + "`;").call(template_variables);
};

const dom = {
    toNodeArray: toNodeArray,
    querySelectorAllAndMe: querySelectorAllAndMe,
    wrap: wrap,
    hide: hide,
    show: show,
    find_parents: find_parents,
    find_scoped: find_scoped,
    get_parents: get_parents,
    acquire_attribute: acquire_attribute,
    is_visible: is_visible,
    create_from_string: create_from_string,
    get_css_value: get_css_value,
    find_scroll_container: find_scroll_container,
    get_data: get_data,
    set_data: set_data,
    template: template,
    add_event_listener: _events__WEBPACK_IMPORTED_MODULE_0__["default"].add_event_listener, // BBB export. TODO: Remove in an upcoming version.
    remove_event_listener: _events__WEBPACK_IMPORTED_MODULE_0__["default"].remove_event_listener, // BBB export. TODO: Remove in an upcoming version.
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dom);


/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/events.js":
/*!******************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/events.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Event related methods and event factories

// Event listener registration for easy-to-remove event listeners.
// once Safari supports the ``signal`` option for addEventListener we can abort
// event handlers by calling AbortController.abort().
const event_listener_map = {};

/**
 * Add an event listener to a DOM element under a unique id.
 * If a event is registered under the same id for the same element, the old handler is removed first.
 *
 * @param {DOM Node} el - The element to register the event for.
 * @param {string} event_type - The event type to listen for.
 * @param {string} id - A unique id under which the event is registered.
 * @param {function} cb - The event handler / callback function.
 * @param {Object} opts - Options for the addEventListener API.
 *
 */
const add_event_listener = (el, event_type, id, cb, opts = {}) => {
    if (!el?.addEventListener) {
        return; // nothing to do.
    }
    remove_event_listener(el, id); // do not register one listener twice.

    if (!event_listener_map[el]) {
        event_listener_map[el] = {};
    }
    event_listener_map[el][id] = [event_type, cb, opts.capture ? opts : undefined]; // prettier-ignore
    el.addEventListener(event_type, cb, opts);
};

/**
 * Remove an event listener from a DOM element under a unique id.
 *
 * @param {DOM Node} el - The element to register the event for.
 * @param {string} id - A unique id under which the event is registered.
 *
 */
const remove_event_listener = (el, id) => {
    if (!el?.removeEventListener) {
        return; // nothing to do.
    }
    const el_events = event_listener_map[el];
    if (!el_events) {
        return;
    }
    let entries;
    if (id) {
        // remove event listener with specific id
        const entry = el_events[id];
        entries = entry ? [entry] : [];
    } else {
        // remove all event listeners of element
        entries = Object.entries(el_events);
    }
    for (const entry of entries || []) {
        el.removeEventListener(entry[0], entry[1], entry[2]);
    }
};

/**
 * Await an event to be thrown.
 *
 * Usage:
 *     await events.await_event(button, "click");
 *
 * @param {DOM Node} el - The element to listen on.
 * @param {String} event_name - The event name to listen for.
 *
 * @returns {Promise} - Returns a Promise which can be used for ``await`` and which will be resolved when the event is throwm.
 *
 */
const await_event = (el, event_name) => {
    // See: https://stackoverflow.com/a/44746691/1337474
    return new Promise((resolve) =>
        el.addEventListener(event_name, resolve, { once: true })
    );
};

/**
 * Await pattern init.
 *
 * Usage:
 *     await events.await_pattern_init(PATTERN);
 *
 * @param {Pattern instance} pattern - The pattern instance.
 *
 * @returns {Promise} - Returns a Promise which can be used for ``await`` and which will be resolved when the event is throwm.
 *
 */
const await_pattern_init = (pattern) => {
    // See: https://stackoverflow.com/a/44746691/1337474
    return new Promise((resolve) => pattern.one("init", resolve));
};

/**
 * Event factories
 */

const click_event = () => {
    return new Event("click", {
        bubbles: true,
        cancelable: true,
    });
};

const change_event = () => {
    return new Event("change", {
        bubbles: true,
        cancelable: false,
    });
};

const input_event = () => {
    return new Event("input", {
        bubbles: true,
        cancelable: false,
    });
};

const mousedown_event = () => {
    return new Event("mousedown", {
        bubbles: true,
        cancelable: true,
    });
};

const mouseup_event = () => {
    return new Event("mouseup", {
        bubbles: true,
        cancelable: true,
    });
};

const scroll_event = () => {
    return new Event("scroll", {
        bubbles: true,
        cancelable: false,
    });
};

const submit_event = () => {
    return new Event("submit", {
        bubbles: true,
        cancelable: true,
    });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    add_event_listener: add_event_listener,
    remove_event_listener: remove_event_listener,
    await_event: await_event,
    await_pattern_init: await_pattern_init,
    click_event: click_event,
    change_event: change_event,
    input_event: input_event,
    mousedown_event: mousedown_event,
    mouseup_event: mouseup_event,
    scroll_event: scroll_event,
    submit_event: submit_event,
});


/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/logging.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/logging.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Patterns logging - minimal logging framework
 *
 * Copyright 2012 Simplon B.V.
 */

// source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== "function") {
            // closest thing possible to the ECMAScript 5 internal IsCallable function
            throw new TypeError(
                "Function.prototype.bind - what is trying to be bound is not callable"
            );
        }

        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function () {},
            fBound = function () {
                return fToBind.apply(
                    this instanceof fNOP && oThis ? this : oThis,
                    aArgs.concat(Array.prototype.slice.call(arguments))
                );
            };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();

        return fBound;
    };
}

var root, // root logger instance
    writer; // writer instance, used to output log entries

var Level = {
    DEBUG: 10,
    INFO: 20,
    WARN: 30,
    ERROR: 40,
    FATAL: 50,
};

function ConsoleWriter() {}

ConsoleWriter.prototype = {
    output: function (log_name, level, messages) {
        if (log_name) messages.unshift(log_name + ":");
        if (level <= Level.DEBUG) {
            // console.debug exists but is deprecated
            messages.unshift("[DEBUG]");
            console.log.apply(console, messages);
        } else if (level <= Level.INFO) console.info.apply(console, messages);
        else if (level <= Level.WARN) console.warn.apply(console, messages);
        else console.error.apply(console, messages);
    },
};

function Logger(name, parent) {
    this._loggers = {};
    this.name = name || "";
    this._parent = parent || null;
    if (!parent) {
        this._enabled = true;
        this._level = Level.WARN;
    }
}

Logger.prototype = {
    getLogger: function (name) {
        var path = name.split("."),
            root = this,
            route = this.name ? [this.name] : [];
        while (path.length) {
            var entry = path.shift();
            route.push(entry);
            if (!(entry in root._loggers))
                root._loggers[entry] = new Logger(route.join("."), root);
            root = root._loggers[entry];
        }
        return root;
    },

    _getFlag: function (flag) {
        var context = this;
        flag = "_" + flag;
        while (context !== null) {
            if (context[flag] !== undefined) return context[flag];
            context = context._parent;
        }
        return null;
    },

    setEnabled: function (state) {
        this._enabled = !!state;
    },

    isEnabled: function () {
        this._getFlag("enabled");
    },

    setLevel: function (level) {
        if (typeof level === "number") this._level = level;
        else if (typeof level === "string") {
            level = level.toUpperCase();
            if (level in Level) this._level = Level[level];
        }
    },

    getLevel: function () {
        return this._getFlag("level");
    },

    log: function (level, messages) {
        if (
            !messages.length ||
            !this._getFlag("enabled") ||
            level < this._getFlag("level")
        )
            return;
        messages = Array.prototype.slice.call(messages);
        writer.output(this.name, level, messages);
    },

    debug: function () {
        this.log(Level.DEBUG, arguments);
    },

    info: function () {
        this.log(Level.INFO, arguments);
    },

    warn: function () {
        this.log(Level.WARN, arguments);
    },

    error: function () {
        this.log(Level.ERROR, arguments);
    },

    fatal: function () {
        this.log(Level.FATAL, arguments);
    },
};

function getWriter() {
    return writer;
}

function setWriter(w) {
    writer = w;
}

setWriter(new ConsoleWriter());

root = new Logger();

var logconfig = /loglevel(|-[^=]+)=([^&]+)/g,
    match;

while ((match = logconfig.exec(window.location.search)) !== null) {
    var logger = match[1] === "" ? root : root.getLogger(match[1].slice(1));
    logger.setLevel(match[2].toUpperCase());
}

var api = {
    Level: Level,
    getLogger: root.getLogger.bind(root),
    setEnabled: root.setEnabled.bind(root),
    isEnabled: root.isEnabled.bind(root),
    setLevel: root.setLevel.bind(root),
    getLevel: root.getLevel.bind(root),
    debug: root.debug.bind(root),
    info: root.info.bind(root),
    warn: root.warn.bind(root),
    error: root.error.bind(root),
    fatal: root.fatal.bind(root),
    getWriter: getWriter,
    setWriter: setWriter,
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (api);


/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/registry.js":
/*!********************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/registry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PATTERN_REGISTRY": () => (/* binding */ PATTERN_REGISTRY),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "webpack/sharing/consume/default/jquery/jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom */ "./node_modules/@patternslib/patternslib/src/core/dom.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging */ "./node_modules/@patternslib/patternslib/src/core/logging.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./node_modules/@patternslib/patternslib/src/core/utils.js");
/**
 * Patterns registry - Central registry and scan logic for patterns
 *
 * Copyright 2012-2013 Simplon B.V.
 * Copyright 2012-2013 Florian Friesdorf
 * Copyright 2013 Marko Durkovic
 * Copyright 2013 Rok Garbas
 * Copyright 2014-2015 Syslab.com GmBH, JC Brand
 */

/*
 * changes to previous patterns.register/scan mechanism
 * - if you want initialised class, do it in init
 * - init returns set of elements actually initialised
 * - handle once within init
 * - no turnstile anymore
 * - set pattern.jquery_plugin if you want it
 */





const log = _logging__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("registry");
const disable_re = /patterns-disable=([^&]+)/g;
const dont_catch_re = /patterns-dont-catch/g;
const disabled = {};
let dont_catch = false;
let match;

while ((match = disable_re.exec(window.location.search)) !== null) {
    disabled[match[1]] = true;
    log.info("Pattern disabled via url config:", match[1]);
}

while ((match = dont_catch_re.exec(window.location.search)) !== null) {
    dont_catch = true;
    log.info("I will not catch init exceptions");
}

/**
 * Global pattern registry.
 *
 * This is a singleton and shared among any instance of the Patternslib
 * registry since Patternslib version 8.
 *
 * You normally don't need this as the registry handles it for you.
 */
if (typeof window.__patternslib_registry === "undefined") {
    window.__patternslib_registry = {};
}
const PATTERN_REGISTRY = window.__patternslib_registry;
if (typeof window.__patternslib_registry_initialized === "undefined") {
    window.__patternslib_registry_initialized = false;
}

const registry = {
    patterns: PATTERN_REGISTRY, // reference to global patterns registry
    // as long as the registry is not initialized, pattern
    // registration just registers a pattern. Once init is called,
    // the DOM is scanned. After that registering a new pattern
    // results in rescanning the DOM only for this pattern.
    init() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
            if (window.__patternslib_registry_initialized) {
                // Do not reinitialize a already initialized registry.
                return;
            }
            window.__patternslib_registry_initialized = true;
            log.debug("Loaded: " + Object.keys(registry.patterns).sort().join(", "));
            registry.scan(document.body);
            log.debug("Finished initial scan.");
        });
    },

    clear() {
        // Removes all patterns from the registry. Currently only being
        // used in tests.
        for (const name in registry.patterns) {
            delete registry.patterns[name];
        }
    },

    transformPattern(name, content) {
        /* Call the transform method on the pattern with the given name, if
         * it exists.
         */
        if (disabled[name]) {
            log.debug(`Skipping disabled pattern: ${name}.`);
            return;
        }

        const pattern = registry.patterns[name];
        const transform = pattern.transform || pattern.prototype?.transform;
        if (transform) {
            try {
                transform(jquery__WEBPACK_IMPORTED_MODULE_0___default()(content));
            } catch (e) {
                if (dont_catch) {
                    throw e;
                }
                log.error(`Transform error for pattern ${name}.`, e);
            }
        }
    },

    initPattern(name, el, trigger) {
        /* Initialize the pattern with the provided name and in the context
         * of the passed in DOM element.
         */
        const $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el);
        const pattern = registry.patterns[name];
        if (pattern.init) {
            const plog = _logging__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger(`pat.${name}`);
            if ($el.is(pattern.trigger)) {
                plog.debug("Initialising.", $el);
                try {
                    pattern.init($el, null, trigger);
                    plog.debug("done.");
                } catch (e) {
                    if (dont_catch) {
                        throw e;
                    }
                    plog.error("Caught error:", e);
                }
            }
        }
    },

    orderPatterns(patterns) {
        // XXX: Bit of a hack. We need the validation pattern to be
        // parsed and initiated before the inject pattern. So we make
        // sure here, that it appears first. Not sure what would be
        // the best solution. Perhaps some kind of way to register
        // patterns "before" or "after" other patterns.
        if (patterns.includes("validation") && patterns.includes("inject")) {
            patterns.splice(patterns.indexOf("validation"), 1);
            patterns.unshift("validation");
        }
        return patterns;
    },

    scan(content, patterns, trigger) {
        if (!content) {
            return;
        }

        if (typeof content === "string") {
            content = document.querySelector(content);
        } else if (content.jquery) {
            content = content[0];
        }

        const selectors = [];
        patterns = this.orderPatterns(patterns || Object.keys(registry.patterns));
        for (const name of patterns) {
            this.transformPattern(name, content);
            const pattern = registry.patterns[name];
            if (pattern.trigger) {
                selectors.unshift(pattern.trigger);
            }
        }

        let matches = _dom__WEBPACK_IMPORTED_MODULE_1__["default"].querySelectorAllAndMe(
            content,
            selectors.map((it) => it.trim().replace(/,$/, "")).join(",")
        );
        matches = matches.filter((el) => {
            // Filter out patterns:
            // - with class ``.disable-patterns``
            // - wrapped in ``.disable-patterns`` elements
            // - wrapped in ``<pre>`` elements
            // - wrapped in ``<template>`` elements
            return (
                !el.matches(".disable-patterns") &&
                !el?.parentNode?.closest?.(".disable-patterns") &&
                !el?.parentNode?.closest?.("pre") &&
                !el?.parentNode?.closest?.("template") && // NOTE: not strictly necessary. Template is a DocumentFragment and not reachable except for IE.
                !el.matches(".cant-touch-this") && // BBB. TODO: Remove with next major version.
                !el?.parentNode?.closest?.(".cant-touch-this") // BBB. TODO: Remove with next major version.
            );
        });

        // walk list backwards and initialize patterns inside-out.
        for (const el of matches.reverse()) {
            for (const name of patterns) {
                this.initPattern(name, el, trigger);
            }
        }
        document.body.classList.add("patterns-loaded");
    },

    register(pattern, name) {
        name = name || pattern.name;
        if (!name) {
            log.error("Pattern lacks a name.", pattern);
            return false;
        }
        if (registry.patterns[name]) {
            log.debug(`Already have a pattern called ${name}.`);
            return false;
        }
        // register pattern to be used for scanning new content
        registry.patterns[name] = pattern;

        // register pattern as jquery plugin
        if (pattern.jquery_plugin) {
            const plugin_name = ("pat-" + name).replace(
                /-([a-zA-Z])/g,
                function (match, p1) {
                    return p1.toUpperCase();
                }
            );
            (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[plugin_name] = _utils__WEBPACK_IMPORTED_MODULE_3__["default"].jqueryPlugin(pattern);
            // BBB 2012-12-10 and also for Mockup patterns.
            (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[plugin_name.replace(/^pat/, "pattern")] = (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[plugin_name];
        }
        log.debug(`Registered pattern ${name}`, pattern);
        if (window.__patternslib_registry_initialized) {
            // Once the first initialization has been done, do only scan for
            // newly registered patterns.
            registry.scan(document.body, [name]);
            log.debug(`Re-scanned dom with newly registered pattern ${name}.`);
        }
        return true;
    },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registry);


/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "webpack/sharing/consume/default/jquery/jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom */ "./node_modules/@patternslib/patternslib/src/core/dom.js");



(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn.safeClone) = function () {
    var $clone = this.clone();
    // IE BUG : Placeholder text becomes actual value after deep clone on textarea
    // https://connect.microsoft.com/IE/feedback/details/781612/placeholder-text-becomes-actual-value-after-deep-clone-on-textarea
    if (window.document.documentMode) {
        $clone.findInclusive(":input[placeholder]").each(function (i, item) {
            var $item = jquery__WEBPACK_IMPORTED_MODULE_0___default()(item);
            if ($item.attr("placeholder") === $item.val()) {
                $item.val("");
            }
        });
    }
    return $clone;
};

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this === null) {
            throw new TypeError(" this is null or not defined");
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== "function") {
            throw new TypeError(callback + " is not a function");
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        // 7. Repeat, while k < len
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}

var singleBoundJQueryPlugin = function (pattern, method, options) {
    /* This is a jQuery plugin for patterns which are invoked ONCE FOR EACH
     * matched element in the DOM.
     *
     * This is how the Mockup-type patterns behave. They are constructor
     * functions which need to be invoked once per jQuery-wrapped DOM node
     * for all DOM nodes on which the pattern applies.
     */
    var $this = this;
    $this.each(function () {
        var pat,
            $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
        pat = pattern.init($el, options);
        if (method) {
            if (pat[method] === undefined) {
                jquery__WEBPACK_IMPORTED_MODULE_0___default().error(
                    "Method " + method + " does not exist on jQuery." + pattern.name
                );
                return false;
            }
            if (method.charAt(0) === "_") {
                jquery__WEBPACK_IMPORTED_MODULE_0___default().error("Method " + method + " is private on jQuery." + pattern.name);
                return false;
            }
            pat[method].apply(pat, [options]);
        }
    });
    return $this;
};

var pluralBoundJQueryPlugin = function (pattern, method, options) {
    /* This is a jQuery plugin for patterns which are invoked ONCE FOR ALL
     * matched elements in the DOM.
     *
     * This is how the vanilla Patternslib-type patterns behave. They are
     * simple objects with an init method and this method gets called once
     * with a list of jQuery-wrapped DOM nodes on which the pattern
     * applies.
     */
    var $this = this;
    if (method) {
        if (pattern[method]) {
            return pattern[method].apply($this, [$this].concat([options]));
        } else {
            jquery__WEBPACK_IMPORTED_MODULE_0___default().error("Method " + method + " does not exist on jQuery." + pattern.name);
        }
    } else {
        pattern.init.apply($this, [$this].concat([options]));
    }
    return $this;
};

var jqueryPlugin = function (pattern) {
    return function (method, options) {
        var $this = this;
        if ($this.length === 0) {
            return $this;
        }
        if (typeof method === "object") {
            options = method;
            method = undefined;
        }
        if (typeof pattern === "function") {
            return singleBoundJQueryPlugin.call(this, pattern, method, options);
        } else {
            return pluralBoundJQueryPlugin.call(this, pattern, method, options);
        }
    };
};

// Is a given variable an object?
function isObject(obj) {
    var type = typeof obj;
    return type === "function" || (type === "object" && !!obj);
}

// Extend a given object with all the properties in passed-in object(s).
function extend(obj) {
    if (!isObject(obj)) return obj;
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        for (prop in source) {
            if (hasOwnProperty.call(source, prop)) {
                obj[prop] = source[prop];
            }
        }
    }
    return obj;
}
// END: Taken from Underscore.js until here.

function rebaseURL(base, url) {
    base = new URL(base, window.location).href; // If base is relative make it absolute.
    if (url.indexOf("://") !== -1 || url[0] === "/" || url.indexOf("data:") === 0) {
        return url;
    }
    return base.slice(0, base.lastIndexOf("/") + 1) + url;
}

function findLabel(input) {
    var $label;
    for (
        var label = input.parentNode;
        label && label.nodeType !== 11;
        label = label.parentNode
    ) {
        if (label.tagName === "LABEL") {
            return label;
        }
    }
    if (input.id) {
        $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()('label[for="' + input.id + '"]');
    }
    if ($label && $label.length === 0 && input.form) {
        $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()('label[for="' + input.name + '"]', input.form);
    }
    if ($label && $label.length) {
        return $label[0];
    } else {
        return null;
    }
}

// Taken from http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport
function elementInViewport(el) {
    var rect = el.getBoundingClientRect(),
        docEl = document.documentElement,
        vWidth = window.innerWidth || docEl.clientWidth,
        vHeight = window.innerHeight || docEl.clientHeight;

    if (rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight)
        return false;
    return true;
}

// Taken from http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

/**
 * Remove classes from a list of targets if they match a specific pattern.
 *
 * @param {Node, NodeList} targets: Dom Node or NodeList where the classes should be removed.
 * @param {string} classes: String matching classes to be removed.
 *                          You can add a "*" as wildcard to search for classes to be removed.
 *                          E.g. "icon-*-alert" to remove any of "icon-1-alert icon-2-alert".
 *
 * @returns {undefined}: This method directly operates on the targets.
 */
function removeWildcardClass(targets, classes) {
    targets = utils.ensureArray(targets);

    if (classes.indexOf("*") === -1) {
        for (const target of targets) {
            target.classList.remove(classes);
        }
    } else {
        let matcher = classes.replace(/[\-\[\]{}()+?.,\\\^$|#\s]/g, "\\$&");
        matcher = matcher.replace(/[*]/g, ".*");
        matcher = new RegExp("^" + matcher + "$");

        for (const target of targets) {
            const class_list = (target.getAttribute("class") || "").split(/\s+/);
            if (!class_list.length) {
                continue;
            }
            const ok = class_list.filter((it) => !matcher.test(it));
            if (ok.length) {
                target.setAttribute("class", ok.join(" "));
            } else {
                target.removeAttribute("class");
            }
        }
    }
}

function hasValue(el) {
    if (el.tagName === "INPUT") {
        if (el.type === "checkbox" || el.type === "radio") {
            return el.checked;
        }
        return el.value !== "";
    }
    if (el.tagName === "SELECT") {
        return el.selectedIndex !== -1;
    }
    if (el.tagName === "TEXTAREA") {
        return el.value !== "";
    }
    return false;
}

const hideOrShow = (nodes, visible, options, pattern_name) => {
    nodes = _dom__WEBPACK_IMPORTED_MODULE_1__["default"].toNodeArray(nodes);

    const transitions = {
        none: { hide: "hide", show: "show" },
        fade: { hide: "fadeOut", show: "fadeIn" },
        slide: { hide: "slideUp", show: "slideDown" },
    };

    const duration =
        options.transition === "css" || options.transition === "none"
            ? null
            : options.effect.duration;

    const on_complete = (el) => {
        el.classList.remove("in-progress");
        el.classList.add(visible ? "visible" : "hidden");
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).trigger("pat-update", {
            pattern: pattern_name,
            transition: "complete",
        });
    };

    for (const el of nodes) {
        el.classList.remove("visible");
        el.classList.remove("hidden");
        el.classList.remove("in-progress");

        if (duration) {
            const t = transitions[options.transition];
            el.classList.add("in-progress");
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).trigger("pat-update", {
                pattern: pattern_name,
                transition: "start",
            });
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(el)[visible ? t.show : t.hide]({
                duration: duration,
                easing: options.effect.easing,
                complete: () => on_complete(el),
            });
        } else {
            if (options.transition !== "css") {
                _dom__WEBPACK_IMPORTED_MODULE_1__["default"][visible ? "show" : "hide"](el);
            }
            on_complete(el);
        }
    }
};

function addURLQueryParameter(fullURL, param, value) {
    /* Using a positive lookahead (?=\=) to find the given parameter,
     * preceded by a ? or &, and followed by a = with a value after
     * than (using a non-greedy selector) and then followed by
     * a & or the end of the string.
     *
     * Taken from http://stackoverflow.com/questions/7640270/adding-modify-query-string-get-variables-in-a-url-with-javascript
     */
    var val = new RegExp("(\\?|\\&)" + param + "=.*?(?=(&|$))"),
        parts = fullURL.toString().split("#"),
        url = parts[0],
        hash = parts[1],
        qstring = /\?.+$/,
        newURL = url;
    // Check if the parameter exists
    if (val.test(url)) {
        // if it does, replace it, using the captured group
        // to determine & or ? at the beginning
        newURL = url.replace(val, "$1" + param + "=" + value);
    } else if (qstring.test(url)) {
        // otherwise, if there is a query string at all
        // add the param to the end of it
        newURL = url + "&" + param + "=" + value;
    } else {
        // if there's no query string, add one
        newURL = url + "?" + param + "=" + value;
    }
    if (hash) {
        newURL += "#" + hash;
    }
    return newURL;
}

function removeDuplicateObjects(objs) {
    /* Given an array of objects, remove any duplicate objects which might
     * be present.
     */
    const comparator = function (k, v) {
        return this[k] === v;
    };

    return objs.reduce(function (list, next_obj) {
        let is_duplicate = false;
        for (const obj of list) {
            is_duplicate =
                Object.keys(obj).length === Object.keys(next_obj).length &&
                Object.entries(obj).filter(
                    (it) => !comparator.bind(next_obj)(it[0], it[1])
                ).length === 0;
        }
        if (!is_duplicate) {
            list.push(next_obj);
        }
        return list;
    }, []);
}

function mergeStack(stack, length) {
    /* Given a list of lists of objects (which for brevity we call a stack),
     * return a list of objects where each object is the merge of all the
     * corresponding original objects at that particular index.
     *
     * If a certain sub-list doesn't have an object at that particular
     * index, the last object in that list is merged.
     */
    const results = [];
    for (let i = 0; i < length; i++) {
        results.push({});
    }
    for (const frame of stack) {
        const frame_length = frame.length - 1;
        for (let x = 0; x < length; x++) {
            results[x] = jquery__WEBPACK_IMPORTED_MODULE_0___default().extend(
                results[x] || {},
                frame[x > frame_length ? frame_length : x]
            );
        }
    }
    return results;
}

function isElementInViewport(el, partial = false, offset = 0) {
    /* returns true if element is visible to the user ie. is in the viewport.
     * Setting partial parameter to true, will only check if a part of the element is visible
     * in the viewport, specifically that some part of that element is touching the top part
     * of the viewport. This only applies to the vertical direction, ie. doesnt check partial
     * visibility for horizontal scrolling
     * some code taken from:
     * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/7557433#7557433
     */
    if (el instanceof (jquery__WEBPACK_IMPORTED_MODULE_0___default())) {
        el = el[0];
    }

    const rec = el.getBoundingClientRect();
    const rec_values = [rec.top, rec.bottom, rec.left, rec.right];

    if (rec_values.every((val) => val === 0)) {
        // if every property of rec is 0, the element is invisible;
        return false;
    } else if (partial) {
        // when using getBoundingClientRect() (in the vertical case)
        // negative means above top of viewport, positive means below top of viewport
        // therefore for part of the element to be touching or crossing the top of the viewport
        // rec.top must <= 0 and rec.bottom must >= 0
        // an optional tolerance offset can be added for when the desired element is not exactly
        // toucing the top of the viewport but needs to be considered as touching.
        return (
            rec.top <= 0 + offset && rec.bottom >= 0 + offset
            //(rec.top >= 0+offset && rec.top <= window.innerHeight) // this checks if the element
            // touches bottom part of viewport
            // XXX do we want to include a check for the padding of an element?
            // using window.getComputedStyle(target).paddingTop
        );
    } else {
        // this will return true if the entire element is completely in the viewport
        return (
            rec.top >= 0 &&
            rec.left >= 0 &&
            rec.bottom <=
                (window.innerHeight || document.documentElement.clientHeight) &&
            rec.right <= (window.innerWidth || document.documentElement.clientWidth)
        );
    }
}

function parseTime(time) {
    var m = /^(\d+(?:\.\d+)?)\s*(\w*)/.exec(time);
    if (!m) {
        throw new Error("Invalid time");
    }
    var amount = parseFloat(m[1]);
    switch (m[2]) {
        case "s":
            return Math.round(amount * 1000);
        case "m":
            return Math.round(amount * 1000 * 60);
        case "ms":
        default:
            return Math.round(amount);
    }
}

// Return a jQuery object with elements related to an input element.
function findRelatives(el) {
    var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el),
        $relatives = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el),
        $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()();

    $relatives = $relatives.add($el.closest("label"));
    $relatives = $relatives.add($el.closest("fieldset"));

    if (el.id) $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()("label[for='" + el.id + "']");
    if (!$label.length) {
        var $form = $el.closest("form");
        if (!$form.length) $form = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body);
        $label = $form.find("label[for='" + el.name + "']");
    }
    $relatives = $relatives.add($label);
    return $relatives;
}

function get_bounds(el) {
    // Return bounds of an element with it's values rounded and converted to ints.
    const bounds = el.getBoundingClientRect();
    return {
        x: parseInt(Math.round(bounds.x), 10) || 0,
        y: parseInt(Math.round(bounds.y), 10) || 0,
        top: parseInt(Math.round(bounds.top), 10) || 0,
        bottom: parseInt(Math.round(bounds.bottom), 10) || 0,
        left: parseInt(Math.round(bounds.left), 10) || 0,
        right: parseInt(Math.round(bounds.right), 10) || 0,
        width: parseInt(Math.round(bounds.width), 10) || 0,
        height: parseInt(Math.round(bounds.height), 10) || 0,
    };
}

function checkInputSupport(type, invalid_value) {
    /* Check input type support.
     *  See: https://stackoverflow.com/a/10199306/1337474
     */
    let support = false;
    const input = document.createElement("input");
    input.setAttribute("type", type);
    support = input.type == type;

    if (invalid_value !== undefined) {
        // Check for input type UI support
        input.setAttribute("value", invalid_value);
        support = input.value !== invalid_value;
    }
    return support;
}

const checkCSSFeature = (attribute, value, tag = "div") => {
    /* Check for browser support of specific CSS feature.
     */
    tag = document.createElement(tag);
    let supported = tag.style[attribute] !== undefined;
    if (supported && value !== undefined) {
        tag.style[attribute] = value;
        supported = tag.style[attribute] === value;
    }
    return supported;
};

const animation_frame = () => {
    // Return promise to await next repaint cycle
    // Use it in your async function like so: ``await utils.animation_frame()``
    // From: http://www.albertlobo.com/fractals/async-await-requestanimationframe-buddhabrot
    return new Promise(window.requestAnimationFrame);
};

const timeout = (ms) => {
    return new Promise((resolve) => setTimeout(resolve, ms));
};

const debounce = (func, ms, timer = { timer: null }) => {
    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds.
    // From: https://underscorejs.org/#debounce
    //
    // Make sure to initialize ``debounce`` only once per to-be-debounced
    // function to not reinitialize the timer each time and debounce not being
    // able to cancel previouse runs.
    //
    // Pass a module-global timer as an object ``{ timer: null }`` if you want
    // to also cancel debounced functions from other pattern-invocations.
    //
    return function () {
        clearTimeout(timer.timer);
        const args = arguments;
        timer.timer = setTimeout(() => func.apply(this, args), ms);
    };
};

const isIE = () => {
    // See: https://stackoverflow.com/a/9851769/1337474
    // Internet Explorer 6-11
    return /*@cc_on!@*/  false || !!document.documentMode;
};

const jqToNode = (el) => {
    // Return a DOM node if a jQuery node was passed.
    if (el.jquery) {
        el = el[0];
    }
    return el;
};

/**
 * Always return an iterable object.
 *
 * @param {any} it: The object which needs to be wrapped in an array or returned as is if it is iterable.
 * @param {boolean} force_array: If the object is iterable but not an Array, convert it to an array (e.g. For jQuery items or NodeList objects).
 *
 * @returns {Array}: Returns the object wrapped in an Array, expanded to an Array or as-is if it is already iterable.
 */
const ensureArray = (it, force_array) => {
    // Ensure to return always an array
    const array_like = !!(
        NodeList.prototype.isPrototypeOf(it) || // eslint-disable-line no-prototype-builtins
        Array.isArray(it) ||
        it.jquery
    );
    return array_like ? (force_array ? [...it] : it) : [it];
};

const localized_isodate = (date) => {
    // Return a iso date (date only) in the current timezone instead of a
    // UTC ISO 8601 date+time component which toISOString returns.

    const day = date.getDate().toString().padStart(2, "0");
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const year = date.getFullYear().toString();

    return `${year}-${month}-${day}`;
};

/**
 * Replace HTML reserved characters with html entities to add HTML for user
 * editing to e.g. a textarea or a contenteditable.
 *
 * See: https://developer.mozilla.org/en-US/docs/Glossary/Entity#reserved_characters
 *
 * @param {string} html - The HTML string to encode.
 *
 * @returns {string} - Returns the escaped html string:
 *                     ``&`` will be replaced with ``&amp;``.
 *                     ``<`` will be repalced with ``&lt;``,
 *                     ``>`` will be replaced with ``&gt;``,
 *                     ``"`` will be replaced with ``&quot;``.
 */
const escape_html = (html) => {
    return (html || "")
        .replace(/&/g, "&amp;") // needs to be first!
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;");
};

/**
 * Return unescaped, raw HTML from an escaped HTML  string.
 *
 * See: https://developer.mozilla.org/en-US/docs/Glossary/Entity#reserved_characters
 *
 * @param {string} escaped_html - The HTML string to decode.
 *
 * @returns {string} - Returns the escaped html string:
 *                     ``&amp;`` will be replaced with ``&``,
 *                     ``&lt;`` will be repalced with ``<``,
 *                     ``&gt;`` will be replaced with ``>``,
 *                     ``&quot;`` will be replaced with ``"``.
 */
const unescape_html = (escaped_html) => {
    return (escaped_html || "")
        .replace(/&amp;/g, "&")
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&quot;/g, '"');
};

/**
 * Return true, if the given value is a valid ISO 8601 date/time string with or without an optional time component.
 *
 * @param {String} value - The date/time value to be checked.
 * @param {Boolean} [optional_time=false] - True, if time component is optional.
 * @return {Boolean} - True, if the given value is a valid Date string. False if not.
 */
const is_iso_date_time = (value, optional_time = false) => {
    const re_date_time = optional_time
        ? /^\d{4}-[01]\d-[0-3]\d(T[0-2]\d:[0-5]\d)?$/
        : /^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d$/;
    return re_date_time.test(value);
};

var utils = {
    // pattern pimping - own module?
    jqueryPlugin: jqueryPlugin,
    escapeRegExp: escapeRegExp,
    isObject: isObject,
    extend: extend,
    rebaseURL: rebaseURL,
    findLabel: findLabel,
    elementInViewport: elementInViewport,
    removeWildcardClass: removeWildcardClass,
    hideOrShow: hideOrShow,
    addURLQueryParameter: addURLQueryParameter,
    removeDuplicateObjects: removeDuplicateObjects,
    mergeStack: mergeStack,
    isElementInViewport: isElementInViewport,
    hasValue: hasValue,
    parseTime: parseTime,
    findRelatives: findRelatives,
    get_bounds: get_bounds,
    checkInputSupport: checkInputSupport,
    checkCSSFeature: checkCSSFeature,
    animation_frame: animation_frame,
    timeout: timeout,
    debounce: debounce,
    isIE: isIE,
    jqToNode: jqToNode,
    ensureArray: ensureArray,
    localized_isodate: localized_isodate,
    escape_html: escape_html,
    unescape_html: unescape_html,
    is_iso_date_time: is_iso_date_time,
    getCSSValue: _dom__WEBPACK_IMPORTED_MODULE_1__["default"].get_css_value, // BBB: moved to dom. TODO: Remove in upcoming version.
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utils);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcGF0dGVybnNsaWJfcGF0dGVybnNsaWJfc3JjX2NvcmVfcmVnaXN0cnlfanMtbm9kZV9tb2R1bGVzX2Nzcy1sb2FkZXJfZGlzLTg3ZGVjOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzhCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtB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Q0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUNoS0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Es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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7QUNyQmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlbGF5b3V0Ly4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuc2xpYi9wYXR0ZXJuc2xpYi9zcmMvY29yZS9kb20uanMiLCJ3ZWJwYWNrOi8vc2ltcGxlbGF5b3V0Ly4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuc2xpYi9wYXR0ZXJuc2xpYi9zcmMvY29yZS9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vc2ltcGxlbGF5b3V0Ly4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuc2xpYi9wYXR0ZXJuc2xpYi9zcmMvY29yZS9sb2dnaW5nLmpzIiwid2VicGFjazovL3NpbXBsZWxheW91dC8uL25vZGVfbW9kdWxlcy9AcGF0dGVybnNsaWIvcGF0dGVybnNsaWIvc3JjL2NvcmUvcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vc2ltcGxlbGF5b3V0Ly4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuc2xpYi9wYXR0ZXJuc2xpYi9zcmMvY29yZS91dGlscy5qcyIsIndlYnBhY2s6Ly9zaW1wbGVsYXlvdXQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3NpbXBsZWxheW91dC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL3NpbXBsZWxheW91dC8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFV0aWxpdGllcyBmb3IgRE9NIHRyYXZlcnNhbCBvciBuYXZpZ2F0aW9uICovXG5pbXBvcnQgZXZlbnRzIGZyb20gXCIuL2V2ZW50c1wiO1xuXG5jb25zdCBEQVRBX1BSRUZJWCA9IFwiX19wYXR0ZXJuc2xpYl9fZGF0YV9wcmVmaXhfX1wiO1xuY29uc3QgREFUQV9TVFlMRV9ESVNQTEFZID0gXCJfX3BhdHRlcm5zbGliX19zdHlsZV9fZGlzcGxheVwiO1xuXG5jb25zdCB0b05vZGVBcnJheSA9IChub2RlcykgPT4ge1xuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAgICBpZiAobm9kZXMuanF1ZXJ5IHx8IG5vZGVzIGluc3RhbmNlb2YgTm9kZUxpc3QpIHtcbiAgICAgICAgLy8galF1ZXJ5IG9yIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGxcbiAgICAgICAgbm9kZXMgPSBbLi4ubm9kZXNdO1xuICAgIH0gZWxzZSBpZiAobm9kZXMgaW5zdGFuY2VvZiBBcnJheSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59O1xuXG5jb25zdCBxdWVyeVNlbGVjdG9yQWxsQW5kTWUgPSAoZWwsIHNlbGVjdG9yKSA9PiB7XG4gICAgLy8gTGlrZSBxdWVyeVNlbGVjdG9yQWxsIGJ1dCBpbmNsdWRpbmcgdGhlIGVsZW1lbnQgd2hlcmUgaXQgc3RhcnRzIGZyb20uXG4gICAgLy8gUmV0dXJucyBhbiBBcnJheSwgbm90IGEgTm9kZUxpc3RcblxuICAgIGlmICghZWwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbCA9IFsuLi5lbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKV07XG4gICAgaWYgKGVsLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgIGFsbC51bnNoaWZ0KGVsKTsgLy8gc3RhcnQgZWxlbWVudCBzaG91bGQgYmUgZmlyc3QuXG4gICAgfVxuICAgIHJldHVybiBhbGw7XG59O1xuXG5jb25zdCB3cmFwID0gKGVsLCB3cmFwcGVyKSA9PiB7XG4gICAgLy8gV3JhcCBhIGVsZW1lbnQgd2l0aCBhIHdyYXBwZXIgZWxlbWVudC5cbiAgICAvLyBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMzE2OTQ2NS8xMzM3NDc0XG5cbiAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBlbCk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChlbCk7XG59O1xuXG5jb25zdCBoaWRlID0gKGVsKSA9PiB7XG4gICAgLy8gSGlkZXMgdGhlIGVsZW1lbnQgd2l0aCBgYGRpc3BsYXk6IG5vbmVgYFxuICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5KSB7XG4gICAgICAgIGVsW0RBVEFfU1RZTEVfRElTUExBWV0gPSBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIH1cbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZWwuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIFwiXCIpO1xufTtcblxuY29uc3Qgc2hvdyA9IChlbCkgPT4ge1xuICAgIC8vIFNob3dzIGVsZW1lbnQgYnkgcmVtb3ZpbmcgYGBkaXNwbGF5OiBub25lYGAgYW5kIHJlc3RvcmluZyB0aGUgZGlzcGxheVxuICAgIC8vIHZhbHVlIHRvIHdoYXRldmVyIGl0IHdhcyBiZWZvcmUuXG4gICAgY29uc3QgdmFsID0gZWxbREFUQV9TVFlMRV9ESVNQTEFZXSB8fCBudWxsO1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWw7XG4gICAgZGVsZXRlIGVsW0RBVEFfU1RZTEVfRElTUExBWV07XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiaGlkZGVuXCIsIFwiXCIpO1xufTtcblxuY29uc3QgZmluZF9wYXJlbnRzID0gKGVsLCBzZWxlY3RvcikgPT4ge1xuICAgIC8vIFJldHVybiBhbGwgZGlyZWN0IHBhcmVudHMgb2YgYGBlbGBgIG1hdGNoaW5nIGBgc2VsZWN0b3JgYC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgYWdhaW5zdCBhbGwgcGFyZW50cyBidXQgbm90IHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAvLyBUaGUgb3JkZXIgb2YgZWxlbWVudHMgaXMgZnJvbSB0aGUgc2VhcmNoIHN0YXJ0aW5nIHBvaW50IHVwIHRvIGhpZ2hlclxuICAgIC8vIERPTSBsZXZlbHMuXG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgbGV0IHBhcmVudCA9IGVsPy5wYXJlbnROb2RlPy5jbG9zZXN0Py4oc2VsZWN0b3IpO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgcmV0LnB1c2gocGFyZW50KTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU/LmNsb3Nlc3Q/LihzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5jb25zdCBmaW5kX3Njb3BlZCA9IChlbCwgc2VsZWN0b3IpID0+IHtcbiAgICAvLyBJZiB0aGUgc2VsZWN0b3Igc3RhcnRzIHdpdGggYW4gb2JqZWN0IGlkIGRvIGEgZ2xvYmFsIHNlYXJjaCxcbiAgICAvLyBvdGhlcndpc2UgZG8gYSBsb2NhbCBzZWFyY2guXG4gICAgcmV0dXJuIChzZWxlY3Rvci5pbmRleE9mKFwiI1wiKSA9PT0gMCA/IGRvY3VtZW50IDogZWwpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xufTtcblxuY29uc3QgZ2V0X3BhcmVudHMgPSAoZWwpID0+IHtcbiAgICAvLyBSZXR1cm4gYWxsIEhUTUxFbGVtZW50IHBhcmVudHMgb2YgZWwsIHN0YXJ0aW5nIGZyb20gdGhlIGRpcmVjdCBwYXJlbnQgb2YgZWwuXG4gICAgLy8gVGhlIGRvY3VtZW50IGl0c2VsZiBpcyBleGNsdWRlZCBiZWNhdXNlIGl0J3Mgbm90IGEgcmVhbCBET00gbm9kZS5cbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgbGV0IHBhcmVudCA9IGVsPy5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudD8ucGFyZW50Tm9kZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBwYXJlbnQgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgYXR0cmlidXRlIGZvdW5kIGluIHRoZSBsaXN0IG9mIHBhcmVudHMuXG4gKlxuICogQHBhcmFtIHtET00gZWxlbWVudH0gZWwgLSBUaGUgRE9NIGVsZW1lbnQgdG8gc3RhcnQgdGhlIGFjcXVpc2l0aW9uIHNlYXJjaCBmb3IgdGhlIGdpdmVuIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZV9lbXB0eSAtIEFsc28gcmV0dXJuIGVtcHR5IHZhbHVlcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZV9hbGwgLSBSZXR1cm4gYSBsaXN0IG9mIGF0dHJpYnV0ZSB2YWx1ZXMgZm91bmQgaW4gYWxsIHBhcmVudHMuXG4gKlxuICogQHJldHVybnMgeyp9IC0gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHNlYXJjaGVkIGF0dHJpYnV0ZSBvciBhIGxpc3Qgb2YgYWxsIGF0dHJpYnV0ZXMuXG4gKi9cbmNvbnN0IGFjcXVpcmVfYXR0cmlidXRlID0gKFxuICAgIGVsLFxuICAgIGF0dHJpYnV0ZSxcbiAgICBpbmNsdWRlX2VtcHR5ID0gZmFsc2UsXG4gICAgaW5jbHVkZV9hbGwgPSBmYWxzZVxuKSA9PiB7XG4gICAgbGV0IF9lbCA9IGVsO1xuICAgIGNvbnN0IHJldCA9IFtdOyAvLyBhcnJheSBmb3IgYGBpbmNsdWRlX2FsbGBgIG1vZGUuXG4gICAgd2hpbGUgKF9lbCkge1xuICAgICAgICBjb25zdCB2YWwgPSBfZWwuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIGlmICh2YWwgfHwgKGluY2x1ZGVfZW1wdHkgJiYgdmFsID09PSBcIlwiKSkge1xuICAgICAgICAgICAgaWYgKCFpbmNsdWRlX2FsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIF9lbCA9IF9lbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZV9hbGwpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59O1xuXG5jb25zdCBpc192aXNpYmxlID0gKGVsKSA9PiB7XG4gICAgLy8gQ2hlY2ssIGlmIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBET00uXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5ODA4MTA3LzEzMzc0NzRcbiAgICByZXR1cm4gZWwub2Zmc2V0V2lkdGggPiAwICYmIGVsLm9mZnNldEhlaWdodCA+IDA7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIERvY3VtZW50RnJhZ21lbnQgZnJvbSBhIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gVGhlIEhUTUwgc3RydWN0dXJlIGFzIGEgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIHtEb2N1bWVudEZyYWdtZW50fSAtIFRoZSBET00gbm9kZXMgYXMgYSBEb2N1bWVudEZyYWdtZW50LlxuICovXG5jb25zdCBjcmVhdGVfZnJvbV9zdHJpbmcgPSAoc3RyaW5nKSA9PiB7XG4gICAgLy8gU2VlOiBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9jb252ZXJ0LWh0bWwtc3RpbmdzLWRvbS1ub2Rlc1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHJpbmcudHJpbSgpKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgQ1NTIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIERPTSBub2RlLlxuICogRm9yIGxlbmd0aC12YWx1ZXMsIHJlbGF0aXZlIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIHBpeGVscy5cbiAqIE9wdGlvbmFsbHkgcGFyc2UgYXMgcGl4ZWxzLCBpZiBhcHBsaWNhYmxlLlxuICpcbiAqIE5vdGU6IFRoZSBlbGVtZW50IG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIGJvZHkgdG8gbWFrZSBDU1MgY2FsdWNsYXRpb25zIHdvcmsuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbCAtIERPTSBub2RlLlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gQ1NTIHByb3BlcnR5IHRvIHF1ZXJ5IG9uIERPTSBub2RlLlxuICogQHBhcmFtIHtCb29sZWFufSBbYXNfcGl4ZWxzPWZhbHNlXSAtIENvbnZlcnQgdmFsdWUgdG8gcGl4ZWxzLCBpZiBhcHBsaWNhYmxlLlxuICogQHBhcmFtIHtCb29sZWFufSBbYXNfZmxvYXQ9ZmFsc2VdIC0gQ29udmVydCB2YWx1ZSB0byBmbG9hdCwgaWYgYXBwbGljYWJsZS5cbiAqXG4gKiBAcmV0dXJucyB7KFN0cmluZ3xOdW1iZXIpfSAtIFRoZSBDU1MgdmFsdWUgdG8gcmV0dXJuLlxuICovXG5mdW5jdGlvbiBnZXRfY3NzX3ZhbHVlKGVsLCBwcm9wZXJ0eSwgYXNfcGl4ZWxzID0gZmFsc2UsIGFzX2Zsb2F0ID0gZmFsc2UpIHtcbiAgICBsZXQgdmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gICAgaWYgKGFzX3BpeGVscyB8fCBhc19mbG9hdCkge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDAuMDtcbiAgICB9XG4gICAgaWYgKGFzX3BpeGVscyAmJiAhYXNfZmxvYXQpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUludChNYXRoLnJvdW5kKHZhbHVlKSwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogRmluZCBhIHNjcm9sbGFibGUgZWxlbWVudCB1cCBpbiB0aGUgRE9NIHRyZWUuXG4gKlxuICogTm90ZTogU2V0dGluZyB0aGUgYGBvdmVyZmxvd2BgIHNob3J0aGFuZCBwcm9wZXJ0eSBhbHNvIHNldHMgdGhlIGluZGl2aWR1YWwgb3ZlcmZsb3cteSBhbmQgb3ZlcmZsb3cteSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZWwgLSBUaGUgRE9NIGVsZW1lbnQgdG8gc3RhcnQgdGhlIHNlYXJjaCBvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZGlyZWN0aW9uPV0gLSBOb3QgZ2l2ZW46IFNlYXJjaCBmb3IgYW55IHNjcm9sbGFibGUgZWxlbWVudCB1cCBpbiB0aGUgRE9NIHRyZWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGB4YGA6IFNlYXJjaCBmb3IgYSBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBgeWBgOiBTZWFyY2ggZm9yIGEgdmVydGljYWxseSBzY3JvbGxhYmxlIGVsZW1lbnQuXG4gKiBAcGFyYW0geyhET00gTm9kZXxudWxsKX0gW2ZhbGxiYWNrPWRvY3VtZW50LmJvZHldIC0gRmFsbGJhY2ssIGlmIG5vIHNjcm9sbCBjb250YWluZXIgY2FuIGJlIGZvdW5kLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IGlzIHRvIHVzZSBkb2N1bWVudC5ib2R5LlxuICpcbiAqIEByZXR1cm5zIHtOb2RlfSAtIFJldHVybiB0aGUgZmlyc3Qgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICogICAgICAgICAgICAgICAgICAgSWYgbm8gb3RoZXIgZWxlbWVudCBjb3VsZCBiZSBmb3VuZCwgZG9jdW1lbnQuYm9keSB3b3VsZCBiZSByZXR1cm5lZC5cbiAqL1xuY29uc3QgZmluZF9zY3JvbGxfY29udGFpbmVyID0gKGVsLCBkaXJlY3Rpb24sIGZhbGxiYWNrID0gZG9jdW1lbnQuYm9keSkgPT4ge1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBpZiAoIWRpcmVjdGlvbiB8fCBkaXJlY3Rpb24gPT09IFwieVwiKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmZsb3dfeSA9IGdldF9jc3NfdmFsdWUoZWwsIFwib3ZlcmZsb3cteVwiKTtcbiAgICAgICAgICAgIGlmIChbXCJhdXRvXCIsIFwic2Nyb2xsXCJdLmluY2x1ZGVzKG92ZXJmbG93X3kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGlyZWN0aW9uIHx8IGRpcmVjdGlvbiA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIGxldCBvdmVyZmxvd194ID0gZ2V0X2Nzc192YWx1ZShlbCwgXCJvdmVyZmxvdy14XCIpO1xuICAgICAgICAgICAgaWYgKFtcImF1dG9cIiwgXCJzY3JvbGxcIl0uaW5jbHVkZXMob3ZlcmZsb3dfeCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG59O1xuXG4vKipcbiAqIEdldCBkYXRhIHN0b3JlZCBkaXJlY3RseSBvbiB0aGUgbm9kZSBpbnN0YW5jZS5cbiAqIFdlIGFyZSB1c2luZyBhIHByZWZpeCB0byBtYWtlIHN1cmUgdGhlIGRhdGEgZG9lc24ndCBjb2xsaWRlIHdpdGggb3RoZXIgYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0gZWwge05vZGV9IC0gVGhlIERPTSBub2RlIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgZGF0YS5cbiAqIEBwYXJhbSBuYW1lIHtTdHJpbmd9IC0gVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlLiBOb3RlIC0gdGhpcyBpcyBzdG9yZWQgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIERPTSBub2RlIHByZWZpeGVkIHdpdGggdGhlIERBVEFfUFJFRklYLlxuICogQHBhcmFtIGRlZmF1bHRfdmFsdWUge0FueX0gLSBPcHRpb25hbCBkZWZhdWx0IHZhbHVlLlxuICogQHJldHVybiB7QW55fSAtIFRoZSB2YWx1ZSB3aGljaCBpcyBzdG9yZWQgb24gdGhlIERPTSBub2RlLlxuICovXG5jb25zdCBnZXRfZGF0YSA9IChlbCwgbmFtZSwgZGVmYXVsdF92YWx1ZSkgPT4ge1xuICAgIHJldHVybiBlbFtgJHtEQVRBX1BSRUZJWH0ke25hbWV9YF0gfHwgZGVmYXVsdF92YWx1ZTtcbn07XG5cbi8qKlxuICogU2V0IGFuZCBzdG9yZSBkYXRhIGRpcmVjdGx5IG9uIHRoZSBub2RlIGluc3RhbmNlLlxuICogV2UgYXJlIHVzaW5nIGEgcHJlZml4IHRvIG1ha2Ugc3VyZSB0aGUgZGF0YSBkb2Vzbid0IGNvbGxpZGUgd2l0aCBvdGhlciBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSBlbCB7Tm9kZX0gLSBUaGUgRE9NIG5vZGUgd2hpY2ggd2Ugd2FudCB0byBzdG9yZSB0aGUgZGF0YSBvbi5cbiAqIEBwYXJhbSBuYW1lIHtTdHJpbmd9IC0gVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlLiBOb3RlIC0gdGhpcyBpcyBzdG9yZWQgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIERPTSBub2RlIHByZWZpeGVkIHdpdGggdGhlIERBVEFfUFJFRklYLlxuICogQHBhcmFtIHZhbHVlIHtBbnl9IC0gVGhlIHZhbHVlIHdlIHdhbnQgdG8gc3RvcmUgb24gdGhlIERPTSBub2RlLlxuICovXG5jb25zdCBzZXRfZGF0YSA9IChlbCwgbmFtZSwgdmFsdWUpID0+IHtcbiAgICBlbFtgJHtEQVRBX1BSRUZJWH0ke25hbWV9YF0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogU2ltcGxlIHRlbXBsYXRlIGVuZ2luZSwgYmFzZWQgb24gSlMgdGVtcGxhdGUgbGl0ZXJhbFxuICpcbiAqIFBsZWFzZSBub3RlOiBZb3UgY2Fubm90IHBhc3MgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIHRlbXBsYXRlX3N0cmluZy5cbiAqIEphdmFTY3JpcHQgaXRzZWxmIHdvdWxkIHRyeSB0byBleHBhbmQgaXQgYW5kIHdvdWxkIGZhaWwuXG4gKlxuICogU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzcyMTcxNjYvMTMzNzQ3NFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZV9zdHJpbmcgLSBUaGUgdGVtcGxhdGUgc3RyaW5nIGFzIGEgSmF2YVNjcmlwdCB0ZW1wbGF0ZSBsaXRlcmFsLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvciBlYWNoIHZhcmlhYmxlIGluIHRoZSB0ZW1wbGF0ZSB5b3UgaGF2ZSB0byB1c2UgYGB0aGlzYGAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRS5nLiBpZiB5b3UgcGFzcyBgYHttZXNzYWdlOiBcIm9rXCJ9YGAgYXMgdGVtcGxhdGVfdmFyaWFibGVzLCB5b3UgY2FuIHVzZSBpdCBsaWtlIHNvOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA8aDE+JHt0aGlzLm1lc3NhZ2V9PC9oMT5gXG4gKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVfdmFyaWFibGVzIC0gT2JqZWN0IGxpdGVyYWwgd2l0aCBhbGwgdGhlIHZhcmlhYmxlcyB3aGljaCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgdGVtcGxhdGUuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gLSBSZXR1cm5zIHRoZSBhIHN0cmluZyBhcyB0ZW1wbGF0ZSBleHBhbmRlZCB3aXRoIHRoZSB0ZW1wbGF0ZV92YXJpYWJsZXMuXG4gKi9cbmNvbnN0IHRlbXBsYXRlID0gKHRlbXBsYXRlX3N0cmluZywgdGVtcGxhdGVfdmFyaWFibGVzID0ge30pID0+IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIGBcIiArIHRlbXBsYXRlX3N0cmluZyArIFwiYDtcIikuY2FsbCh0ZW1wbGF0ZV92YXJpYWJsZXMpO1xufTtcblxuY29uc3QgZG9tID0ge1xuICAgIHRvTm9kZUFycmF5OiB0b05vZGVBcnJheSxcbiAgICBxdWVyeVNlbGVjdG9yQWxsQW5kTWU6IHF1ZXJ5U2VsZWN0b3JBbGxBbmRNZSxcbiAgICB3cmFwOiB3cmFwLFxuICAgIGhpZGU6IGhpZGUsXG4gICAgc2hvdzogc2hvdyxcbiAgICBmaW5kX3BhcmVudHM6IGZpbmRfcGFyZW50cyxcbiAgICBmaW5kX3Njb3BlZDogZmluZF9zY29wZWQsXG4gICAgZ2V0X3BhcmVudHM6IGdldF9wYXJlbnRzLFxuICAgIGFjcXVpcmVfYXR0cmlidXRlOiBhY3F1aXJlX2F0dHJpYnV0ZSxcbiAgICBpc192aXNpYmxlOiBpc192aXNpYmxlLFxuICAgIGNyZWF0ZV9mcm9tX3N0cmluZzogY3JlYXRlX2Zyb21fc3RyaW5nLFxuICAgIGdldF9jc3NfdmFsdWU6IGdldF9jc3NfdmFsdWUsXG4gICAgZmluZF9zY3JvbGxfY29udGFpbmVyOiBmaW5kX3Njcm9sbF9jb250YWluZXIsXG4gICAgZ2V0X2RhdGE6IGdldF9kYXRhLFxuICAgIHNldF9kYXRhOiBzZXRfZGF0YSxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgYWRkX2V2ZW50X2xpc3RlbmVyOiBldmVudHMuYWRkX2V2ZW50X2xpc3RlbmVyLCAvLyBCQkIgZXhwb3J0LiBUT0RPOiBSZW1vdmUgaW4gYW4gdXBjb21pbmcgdmVyc2lvbi5cbiAgICByZW1vdmVfZXZlbnRfbGlzdGVuZXI6IGV2ZW50cy5yZW1vdmVfZXZlbnRfbGlzdGVuZXIsIC8vIEJCQiBleHBvcnQuIFRPRE86IFJlbW92ZSBpbiBhbiB1cGNvbWluZyB2ZXJzaW9uLlxufTtcblxuZXhwb3J0IGRlZmF1bHQgZG9tO1xuIiwiLy8gRXZlbnQgcmVsYXRlZCBtZXRob2RzIGFuZCBldmVudCBmYWN0b3JpZXNcblxuLy8gRXZlbnQgbGlzdGVuZXIgcmVnaXN0cmF0aW9uIGZvciBlYXN5LXRvLXJlbW92ZSBldmVudCBsaXN0ZW5lcnMuXG4vLyBvbmNlIFNhZmFyaSBzdXBwb3J0cyB0aGUgYGBzaWduYWxgYCBvcHRpb24gZm9yIGFkZEV2ZW50TGlzdGVuZXIgd2UgY2FuIGFib3J0XG4vLyBldmVudCBoYW5kbGVycyBieSBjYWxsaW5nIEFib3J0Q29udHJvbGxlci5hYm9ydCgpLlxuY29uc3QgZXZlbnRfbGlzdGVuZXJfbWFwID0ge307XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGEgRE9NIGVsZW1lbnQgdW5kZXIgYSB1bmlxdWUgaWQuXG4gKiBJZiBhIGV2ZW50IGlzIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNhbWUgaWQgZm9yIHRoZSBzYW1lIGVsZW1lbnQsIHRoZSBvbGQgaGFuZGxlciBpcyByZW1vdmVkIGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7RE9NIE5vZGV9IGVsIC0gVGhlIGVsZW1lbnQgdG8gcmVnaXN0ZXIgdGhlIGV2ZW50IGZvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF90eXBlIC0gVGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIEEgdW5pcXVlIGlkIHVuZGVyIHdoaWNoIHRoZSBldmVudCBpcyByZWdpc3RlcmVkLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgLSBUaGUgZXZlbnQgaGFuZGxlciAvIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIGZvciB0aGUgYWRkRXZlbnRMaXN0ZW5lciBBUEkuXG4gKlxuICovXG5jb25zdCBhZGRfZXZlbnRfbGlzdGVuZXIgPSAoZWwsIGV2ZW50X3R5cGUsIGlkLCBjYiwgb3B0cyA9IHt9KSA9PiB7XG4gICAgaWYgKCFlbD8uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm47IC8vIG5vdGhpbmcgdG8gZG8uXG4gICAgfVxuICAgIHJlbW92ZV9ldmVudF9saXN0ZW5lcihlbCwgaWQpOyAvLyBkbyBub3QgcmVnaXN0ZXIgb25lIGxpc3RlbmVyIHR3aWNlLlxuXG4gICAgaWYgKCFldmVudF9saXN0ZW5lcl9tYXBbZWxdKSB7XG4gICAgICAgIGV2ZW50X2xpc3RlbmVyX21hcFtlbF0gPSB7fTtcbiAgICB9XG4gICAgZXZlbnRfbGlzdGVuZXJfbWFwW2VsXVtpZF0gPSBbZXZlbnRfdHlwZSwgY2IsIG9wdHMuY2FwdHVyZSA/IG9wdHMgOiB1bmRlZmluZWRdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X3R5cGUsIGNiLCBvcHRzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYSBET00gZWxlbWVudCB1bmRlciBhIHVuaXF1ZSBpZC5cbiAqXG4gKiBAcGFyYW0ge0RPTSBOb2RlfSBlbCAtIFRoZSBlbGVtZW50IHRvIHJlZ2lzdGVyIHRoZSBldmVudCBmb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBBIHVuaXF1ZSBpZCB1bmRlciB3aGljaCB0aGUgZXZlbnQgaXMgcmVnaXN0ZXJlZC5cbiAqXG4gKi9cbmNvbnN0IHJlbW92ZV9ldmVudF9saXN0ZW5lciA9IChlbCwgaWQpID0+IHtcbiAgICBpZiAoIWVsPy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybjsgLy8gbm90aGluZyB0byBkby5cbiAgICB9XG4gICAgY29uc3QgZWxfZXZlbnRzID0gZXZlbnRfbGlzdGVuZXJfbWFwW2VsXTtcbiAgICBpZiAoIWVsX2V2ZW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBlbnRyaWVzO1xuICAgIGlmIChpZCkge1xuICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXIgd2l0aCBzcGVjaWZpYyBpZFxuICAgICAgICBjb25zdCBlbnRyeSA9IGVsX2V2ZW50c1tpZF07XG4gICAgICAgIGVudHJpZXMgPSBlbnRyeSA/IFtlbnRyeV0gOiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycyBvZiBlbGVtZW50XG4gICAgICAgIGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlbF9ldmVudHMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMgfHwgW10pIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbnRyeVswXSwgZW50cnlbMV0sIGVudHJ5WzJdKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEF3YWl0IGFuIGV2ZW50IHRvIGJlIHRocm93bi5cbiAqXG4gKiBVc2FnZTpcbiAqICAgICBhd2FpdCBldmVudHMuYXdhaXRfZXZlbnQoYnV0dG9uLCBcImNsaWNrXCIpO1xuICpcbiAqIEBwYXJhbSB7RE9NIE5vZGV9IGVsIC0gVGhlIGVsZW1lbnQgdG8gbGlzdGVuIG9uLlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgLSBUaGUgZXZlbnQgbmFtZSB0byBsaXN0ZW4gZm9yLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIFJldHVybnMgYSBQcm9taXNlIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBgYGF3YWl0YGAgYW5kIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZXZlbnQgaXMgdGhyb3dtLlxuICpcbiAqL1xuY29uc3QgYXdhaXRfZXZlbnQgPSAoZWwsIGV2ZW50X25hbWUpID0+IHtcbiAgICAvLyBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NDc0NjY5MS8xMzM3NDc0XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIHJlc29sdmUsIHsgb25jZTogdHJ1ZSB9KVxuICAgICk7XG59O1xuXG4vKipcbiAqIEF3YWl0IHBhdHRlcm4gaW5pdC5cbiAqXG4gKiBVc2FnZTpcbiAqICAgICBhd2FpdCBldmVudHMuYXdhaXRfcGF0dGVybl9pbml0KFBBVFRFUk4pO1xuICpcbiAqIEBwYXJhbSB7UGF0dGVybiBpbnN0YW5jZX0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIFJldHVybnMgYSBQcm9taXNlIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBgYGF3YWl0YGAgYW5kIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgZXZlbnQgaXMgdGhyb3dtLlxuICpcbiAqL1xuY29uc3QgYXdhaXRfcGF0dGVybl9pbml0ID0gKHBhdHRlcm4pID0+IHtcbiAgICAvLyBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NDc0NjY5MS8xMzM3NDc0XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBwYXR0ZXJuLm9uZShcImluaXRcIiwgcmVzb2x2ZSkpO1xufTtcblxuLyoqXG4gKiBFdmVudCBmYWN0b3JpZXNcbiAqL1xuXG5jb25zdCBjbGlja19ldmVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IEV2ZW50KFwiY2xpY2tcIiwge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIH0pO1xufTtcblxuY29uc3QgY2hhbmdlX2V2ZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgRXZlbnQoXCJjaGFuZ2VcIiwge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IGlucHV0X2V2ZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgRXZlbnQoXCJpbnB1dFwiLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgIH0pO1xufTtcblxuY29uc3QgbW91c2Vkb3duX2V2ZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgRXZlbnQoXCJtb3VzZWRvd25cIiwge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIH0pO1xufTtcblxuY29uc3QgbW91c2V1cF9ldmVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IEV2ZW50KFwibW91c2V1cFwiLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgfSk7XG59O1xuXG5jb25zdCBzY3JvbGxfZXZlbnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBFdmVudChcInNjcm9sbFwiLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgIH0pO1xufTtcblxuY29uc3Qgc3VibWl0X2V2ZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgRXZlbnQoXCJzdWJtaXRcIiwge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGFkZF9ldmVudF9saXN0ZW5lcjogYWRkX2V2ZW50X2xpc3RlbmVyLFxuICAgIHJlbW92ZV9ldmVudF9saXN0ZW5lcjogcmVtb3ZlX2V2ZW50X2xpc3RlbmVyLFxuICAgIGF3YWl0X2V2ZW50OiBhd2FpdF9ldmVudCxcbiAgICBhd2FpdF9wYXR0ZXJuX2luaXQ6IGF3YWl0X3BhdHRlcm5faW5pdCxcbiAgICBjbGlja19ldmVudDogY2xpY2tfZXZlbnQsXG4gICAgY2hhbmdlX2V2ZW50OiBjaGFuZ2VfZXZlbnQsXG4gICAgaW5wdXRfZXZlbnQ6IGlucHV0X2V2ZW50LFxuICAgIG1vdXNlZG93bl9ldmVudDogbW91c2Vkb3duX2V2ZW50LFxuICAgIG1vdXNldXBfZXZlbnQ6IG1vdXNldXBfZXZlbnQsXG4gICAgc2Nyb2xsX2V2ZW50OiBzY3JvbGxfZXZlbnQsXG4gICAgc3VibWl0X2V2ZW50OiBzdWJtaXRfZXZlbnQsXG59O1xuIiwiLyoqXG4gKiBQYXR0ZXJucyBsb2dnaW5nIC0gbWluaW1hbCBsb2dnaW5nIGZyYW1ld29ya1xuICpcbiAqIENvcHlyaWdodCAyMDEyIFNpbXBsb24gQi5WLlxuICovXG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAob1RoaXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgICAgIGZOT1AgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgIGZCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXMgPyB0aGlzIDogb1RoaXMsXG4gICAgICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcblxuICAgICAgICByZXR1cm4gZkJvdW5kO1xuICAgIH07XG59XG5cbnZhciByb290LCAvLyByb290IGxvZ2dlciBpbnN0YW5jZVxuICAgIHdyaXRlcjsgLy8gd3JpdGVyIGluc3RhbmNlLCB1c2VkIHRvIG91dHB1dCBsb2cgZW50cmllc1xuXG52YXIgTGV2ZWwgPSB7XG4gICAgREVCVUc6IDEwLFxuICAgIElORk86IDIwLFxuICAgIFdBUk46IDMwLFxuICAgIEVSUk9SOiA0MCxcbiAgICBGQVRBTDogNTAsXG59O1xuXG5mdW5jdGlvbiBDb25zb2xlV3JpdGVyKCkge31cblxuQ29uc29sZVdyaXRlci5wcm90b3R5cGUgPSB7XG4gICAgb3V0cHV0OiBmdW5jdGlvbiAobG9nX25hbWUsIGxldmVsLCBtZXNzYWdlcykge1xuICAgICAgICBpZiAobG9nX25hbWUpIG1lc3NhZ2VzLnVuc2hpZnQobG9nX25hbWUgKyBcIjpcIik7XG4gICAgICAgIGlmIChsZXZlbCA8PSBMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyBleGlzdHMgYnV0IGlzIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgIG1lc3NhZ2VzLnVuc2hpZnQoXCJbREVCVUddXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgbWVzc2FnZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVsIDw9IExldmVsLklORk8pIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBtZXNzYWdlcyk7XG4gICAgICAgIGVsc2UgaWYgKGxldmVsIDw9IExldmVsLldBUk4pIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBtZXNzYWdlcyk7XG4gICAgICAgIGVsc2UgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBtZXNzYWdlcyk7XG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIExvZ2dlcihuYW1lLCBwYXJlbnQpIHtcbiAgICB0aGlzLl9sb2dnZXJzID0ge307XG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcIlwiO1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sZXZlbCA9IExldmVsLldBUk47XG4gICAgfVxufVxuXG5Mb2dnZXIucHJvdG90eXBlID0ge1xuICAgIGdldExvZ2dlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBuYW1lLnNwbGl0KFwiLlwiKSxcbiAgICAgICAgICAgIHJvb3QgPSB0aGlzLFxuICAgICAgICAgICAgcm91dGUgPSB0aGlzLm5hbWUgPyBbdGhpcy5uYW1lXSA6IFtdO1xuICAgICAgICB3aGlsZSAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIHJvdXRlLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgaWYgKCEoZW50cnkgaW4gcm9vdC5fbG9nZ2VycykpXG4gICAgICAgICAgICAgICAgcm9vdC5fbG9nZ2Vyc1tlbnRyeV0gPSBuZXcgTG9nZ2VyKHJvdXRlLmpvaW4oXCIuXCIpLCByb290KTtcbiAgICAgICAgICAgIHJvb3QgPSByb290Ll9sb2dnZXJzW2VudHJ5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9LFxuXG4gICAgX2dldEZsYWc6IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgZmxhZyA9IFwiX1wiICsgZmxhZztcbiAgICAgICAgd2hpbGUgKGNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0W2ZsYWddICE9PSB1bmRlZmluZWQpIHJldHVybiBjb250ZXh0W2ZsYWddO1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSAhIXN0YXRlO1xuICAgIH0sXG5cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ2V0RmxhZyhcImVuYWJsZWRcIik7XG4gICAgfSxcblxuICAgIHNldExldmVsOiBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIikgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXZlbCA9IGxldmVsLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobGV2ZWwgaW4gTGV2ZWwpIHRoaXMuX2xldmVsID0gTGV2ZWxbbGV2ZWxdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldExldmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGbGFnKFwibGV2ZWxcIik7XG4gICAgfSxcblxuICAgIGxvZzogZnVuY3Rpb24gKGxldmVsLCBtZXNzYWdlcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWVzc2FnZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAhdGhpcy5fZ2V0RmxhZyhcImVuYWJsZWRcIikgfHxcbiAgICAgICAgICAgIGxldmVsIDwgdGhpcy5fZ2V0RmxhZyhcImxldmVsXCIpXG4gICAgICAgIClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWVzc2FnZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlcyk7XG4gICAgICAgIHdyaXRlci5vdXRwdXQodGhpcy5uYW1lLCBsZXZlbCwgbWVzc2FnZXMpO1xuICAgIH0sXG5cbiAgICBkZWJ1ZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZyhMZXZlbC5ERUJVRywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgaW5mbzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZyhMZXZlbC5JTkZPLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICB3YXJuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nKExldmVsLldBUk4sIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nKExldmVsLkVSUk9SLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBmYXRhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZyhMZXZlbC5GQVRBTCwgYXJndW1lbnRzKTtcbiAgICB9LFxufTtcblxuZnVuY3Rpb24gZ2V0V3JpdGVyKCkge1xuICAgIHJldHVybiB3cml0ZXI7XG59XG5cbmZ1bmN0aW9uIHNldFdyaXRlcih3KSB7XG4gICAgd3JpdGVyID0gdztcbn1cblxuc2V0V3JpdGVyKG5ldyBDb25zb2xlV3JpdGVyKCkpO1xuXG5yb290ID0gbmV3IExvZ2dlcigpO1xuXG52YXIgbG9nY29uZmlnID0gL2xvZ2xldmVsKHwtW149XSspPShbXiZdKykvZyxcbiAgICBtYXRjaDtcblxud2hpbGUgKChtYXRjaCA9IGxvZ2NvbmZpZy5leGVjKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpKSAhPT0gbnVsbCkge1xuICAgIHZhciBsb2dnZXIgPSBtYXRjaFsxXSA9PT0gXCJcIiA/IHJvb3QgOiByb290LmdldExvZ2dlcihtYXRjaFsxXS5zbGljZSgxKSk7XG4gICAgbG9nZ2VyLnNldExldmVsKG1hdGNoWzJdLnRvVXBwZXJDYXNlKCkpO1xufVxuXG52YXIgYXBpID0ge1xuICAgIExldmVsOiBMZXZlbCxcbiAgICBnZXRMb2dnZXI6IHJvb3QuZ2V0TG9nZ2VyLmJpbmQocm9vdCksXG4gICAgc2V0RW5hYmxlZDogcm9vdC5zZXRFbmFibGVkLmJpbmQocm9vdCksXG4gICAgaXNFbmFibGVkOiByb290LmlzRW5hYmxlZC5iaW5kKHJvb3QpLFxuICAgIHNldExldmVsOiByb290LnNldExldmVsLmJpbmQocm9vdCksXG4gICAgZ2V0TGV2ZWw6IHJvb3QuZ2V0TGV2ZWwuYmluZChyb290KSxcbiAgICBkZWJ1Zzogcm9vdC5kZWJ1Zy5iaW5kKHJvb3QpLFxuICAgIGluZm86IHJvb3QuaW5mby5iaW5kKHJvb3QpLFxuICAgIHdhcm46IHJvb3Qud2Fybi5iaW5kKHJvb3QpLFxuICAgIGVycm9yOiByb290LmVycm9yLmJpbmQocm9vdCksXG4gICAgZmF0YWw6IHJvb3QuZmF0YWwuYmluZChyb290KSxcbiAgICBnZXRXcml0ZXI6IGdldFdyaXRlcixcbiAgICBzZXRXcml0ZXI6IHNldFdyaXRlcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFwaTtcbiIsIi8qKlxuICogUGF0dGVybnMgcmVnaXN0cnkgLSBDZW50cmFsIHJlZ2lzdHJ5IGFuZCBzY2FuIGxvZ2ljIGZvciBwYXR0ZXJuc1xuICpcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgU2ltcGxvbiBCLlYuXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIEZsb3JpYW4gRnJpZXNkb3JmXG4gKiBDb3B5cmlnaHQgMjAxMyBNYXJrbyBEdXJrb3ZpY1xuICogQ29weXJpZ2h0IDIwMTMgUm9rIEdhcmJhc1xuICogQ29weXJpZ2h0IDIwMTQtMjAxNSBTeXNsYWIuY29tIEdtQkgsIEpDIEJyYW5kXG4gKi9cblxuLypcbiAqIGNoYW5nZXMgdG8gcHJldmlvdXMgcGF0dGVybnMucmVnaXN0ZXIvc2NhbiBtZWNoYW5pc21cbiAqIC0gaWYgeW91IHdhbnQgaW5pdGlhbGlzZWQgY2xhc3MsIGRvIGl0IGluIGluaXRcbiAqIC0gaW5pdCByZXR1cm5zIHNldCBvZiBlbGVtZW50cyBhY3R1YWxseSBpbml0aWFsaXNlZFxuICogLSBoYW5kbGUgb25jZSB3aXRoaW4gaW5pdFxuICogLSBubyB0dXJuc3RpbGUgYW55bW9yZVxuICogLSBzZXQgcGF0dGVybi5qcXVlcnlfcGx1Z2luIGlmIHlvdSB3YW50IGl0XG4gKi9cbmltcG9ydCAkIGZyb20gXCJqcXVlcnlcIjtcbmltcG9ydCBkb20gZnJvbSBcIi4vZG9tXCI7XG5pbXBvcnQgbG9nZ2luZyBmcm9tIFwiLi9sb2dnaW5nXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4vdXRpbHNcIjtcblxuY29uc3QgbG9nID0gbG9nZ2luZy5nZXRMb2dnZXIoXCJyZWdpc3RyeVwiKTtcbmNvbnN0IGRpc2FibGVfcmUgPSAvcGF0dGVybnMtZGlzYWJsZT0oW14mXSspL2c7XG5jb25zdCBkb250X2NhdGNoX3JlID0gL3BhdHRlcm5zLWRvbnQtY2F0Y2gvZztcbmNvbnN0IGRpc2FibGVkID0ge307XG5sZXQgZG9udF9jYXRjaCA9IGZhbHNlO1xubGV0IG1hdGNoO1xuXG53aGlsZSAoKG1hdGNoID0gZGlzYWJsZV9yZS5leGVjKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpKSAhPT0gbnVsbCkge1xuICAgIGRpc2FibGVkW21hdGNoWzFdXSA9IHRydWU7XG4gICAgbG9nLmluZm8oXCJQYXR0ZXJuIGRpc2FibGVkIHZpYSB1cmwgY29uZmlnOlwiLCBtYXRjaFsxXSk7XG59XG5cbndoaWxlICgobWF0Y2ggPSBkb250X2NhdGNoX3JlLmV4ZWMod2luZG93LmxvY2F0aW9uLnNlYXJjaCkpICE9PSBudWxsKSB7XG4gICAgZG9udF9jYXRjaCA9IHRydWU7XG4gICAgbG9nLmluZm8oXCJJIHdpbGwgbm90IGNhdGNoIGluaXQgZXhjZXB0aW9uc1wiKTtcbn1cblxuLyoqXG4gKiBHbG9iYWwgcGF0dGVybiByZWdpc3RyeS5cbiAqXG4gKiBUaGlzIGlzIGEgc2luZ2xldG9uIGFuZCBzaGFyZWQgYW1vbmcgYW55IGluc3RhbmNlIG9mIHRoZSBQYXR0ZXJuc2xpYlxuICogcmVnaXN0cnkgc2luY2UgUGF0dGVybnNsaWIgdmVyc2lvbiA4LlxuICpcbiAqIFlvdSBub3JtYWxseSBkb24ndCBuZWVkIHRoaXMgYXMgdGhlIHJlZ2lzdHJ5IGhhbmRsZXMgaXQgZm9yIHlvdS5cbiAqL1xuaWYgKHR5cGVvZiB3aW5kb3cuX19wYXR0ZXJuc2xpYl9yZWdpc3RyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5fX3BhdHRlcm5zbGliX3JlZ2lzdHJ5ID0ge307XG59XG5leHBvcnQgY29uc3QgUEFUVEVSTl9SRUdJU1RSWSA9IHdpbmRvdy5fX3BhdHRlcm5zbGliX3JlZ2lzdHJ5O1xuaWYgKHR5cGVvZiB3aW5kb3cuX19wYXR0ZXJuc2xpYl9yZWdpc3RyeV9pbml0aWFsaXplZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5fX3BhdHRlcm5zbGliX3JlZ2lzdHJ5X2luaXRpYWxpemVkID0gZmFsc2U7XG59XG5cbmNvbnN0IHJlZ2lzdHJ5ID0ge1xuICAgIHBhdHRlcm5zOiBQQVRURVJOX1JFR0lTVFJZLCAvLyByZWZlcmVuY2UgdG8gZ2xvYmFsIHBhdHRlcm5zIHJlZ2lzdHJ5XG4gICAgLy8gYXMgbG9uZyBhcyB0aGUgcmVnaXN0cnkgaXMgbm90IGluaXRpYWxpemVkLCBwYXR0ZXJuXG4gICAgLy8gcmVnaXN0cmF0aW9uIGp1c3QgcmVnaXN0ZXJzIGEgcGF0dGVybi4gT25jZSBpbml0IGlzIGNhbGxlZCxcbiAgICAvLyB0aGUgRE9NIGlzIHNjYW5uZWQuIEFmdGVyIHRoYXQgcmVnaXN0ZXJpbmcgYSBuZXcgcGF0dGVyblxuICAgIC8vIHJlc3VsdHMgaW4gcmVzY2FubmluZyB0aGUgRE9NIG9ubHkgZm9yIHRoaXMgcGF0dGVybi5cbiAgICBpbml0KCkge1xuICAgICAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fcGF0dGVybnNsaWJfcmVnaXN0cnlfaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgcmVpbml0aWFsaXplIGEgYWxyZWFkeSBpbml0aWFsaXplZCByZWdpc3RyeS5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuX19wYXR0ZXJuc2xpYl9yZWdpc3RyeV9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJMb2FkZWQ6IFwiICsgT2JqZWN0LmtleXMocmVnaXN0cnkucGF0dGVybnMpLnNvcnQoKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgcmVnaXN0cnkuc2Nhbihkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkZpbmlzaGVkIGluaXRpYWwgc2Nhbi5cIik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgLy8gUmVtb3ZlcyBhbGwgcGF0dGVybnMgZnJvbSB0aGUgcmVnaXN0cnkuIEN1cnJlbnRseSBvbmx5IGJlaW5nXG4gICAgICAgIC8vIHVzZWQgaW4gdGVzdHMuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiByZWdpc3RyeS5wYXR0ZXJucykge1xuICAgICAgICAgICAgZGVsZXRlIHJlZ2lzdHJ5LnBhdHRlcm5zW25hbWVdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybVBhdHRlcm4obmFtZSwgY29udGVudCkge1xuICAgICAgICAvKiBDYWxsIHRoZSB0cmFuc2Zvcm0gbWV0aG9kIG9uIHRoZSBwYXR0ZXJuIHdpdGggdGhlIGdpdmVuIG5hbWUsIGlmXG4gICAgICAgICAqIGl0IGV4aXN0cy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChkaXNhYmxlZFtuYW1lXSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBTa2lwcGluZyBkaXNhYmxlZCBwYXR0ZXJuOiAke25hbWV9LmApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHJlZ2lzdHJ5LnBhdHRlcm5zW25hbWVdO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBwYXR0ZXJuLnRyYW5zZm9ybSB8fCBwYXR0ZXJuLnByb3RvdHlwZT8udHJhbnNmb3JtO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSgkKGNvbnRlbnQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9udF9jYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoYFRyYW5zZm9ybSBlcnJvciBmb3IgcGF0dGVybiAke25hbWV9LmAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluaXRQYXR0ZXJuKG5hbWUsIGVsLCB0cmlnZ2VyKSB7XG4gICAgICAgIC8qIEluaXRpYWxpemUgdGhlIHBhdHRlcm4gd2l0aCB0aGUgcHJvdmlkZWQgbmFtZSBhbmQgaW4gdGhlIGNvbnRleHRcbiAgICAgICAgICogb2YgdGhlIHBhc3NlZCBpbiBET00gZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gcmVnaXN0cnkucGF0dGVybnNbbmFtZV07XG4gICAgICAgIGlmIChwYXR0ZXJuLmluaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsb2cgPSBsb2dnaW5nLmdldExvZ2dlcihgcGF0LiR7bmFtZX1gKTtcbiAgICAgICAgICAgIGlmICgkZWwuaXMocGF0dGVybi50cmlnZ2VyKSkge1xuICAgICAgICAgICAgICAgIHBsb2cuZGVidWcoXCJJbml0aWFsaXNpbmcuXCIsICRlbCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5pbml0KCRlbCwgbnVsbCwgdHJpZ2dlcik7XG4gICAgICAgICAgICAgICAgICAgIHBsb2cuZGVidWcoXCJkb25lLlwiKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb250X2NhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBsb2cuZXJyb3IoXCJDYXVnaHQgZXJyb3I6XCIsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvcmRlclBhdHRlcm5zKHBhdHRlcm5zKSB7XG4gICAgICAgIC8vIFhYWDogQml0IG9mIGEgaGFjay4gV2UgbmVlZCB0aGUgdmFsaWRhdGlvbiBwYXR0ZXJuIHRvIGJlXG4gICAgICAgIC8vIHBhcnNlZCBhbmQgaW5pdGlhdGVkIGJlZm9yZSB0aGUgaW5qZWN0IHBhdHRlcm4uIFNvIHdlIG1ha2VcbiAgICAgICAgLy8gc3VyZSBoZXJlLCB0aGF0IGl0IGFwcGVhcnMgZmlyc3QuIE5vdCBzdXJlIHdoYXQgd291bGQgYmVcbiAgICAgICAgLy8gdGhlIGJlc3Qgc29sdXRpb24uIFBlcmhhcHMgc29tZSBraW5kIG9mIHdheSB0byByZWdpc3RlclxuICAgICAgICAvLyBwYXR0ZXJucyBcImJlZm9yZVwiIG9yIFwiYWZ0ZXJcIiBvdGhlciBwYXR0ZXJucy5cbiAgICAgICAgaWYgKHBhdHRlcm5zLmluY2x1ZGVzKFwidmFsaWRhdGlvblwiKSAmJiBwYXR0ZXJucy5pbmNsdWRlcyhcImluamVjdFwiKSkge1xuICAgICAgICAgICAgcGF0dGVybnMuc3BsaWNlKHBhdHRlcm5zLmluZGV4T2YoXCJ2YWxpZGF0aW9uXCIpLCAxKTtcbiAgICAgICAgICAgIHBhdHRlcm5zLnVuc2hpZnQoXCJ2YWxpZGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXR0ZXJucztcbiAgICB9LFxuXG4gICAgc2Nhbihjb250ZW50LCBwYXR0ZXJucywgdHJpZ2dlcikge1xuICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudC5qcXVlcnkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50WzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VsZWN0b3JzID0gW107XG4gICAgICAgIHBhdHRlcm5zID0gdGhpcy5vcmRlclBhdHRlcm5zKHBhdHRlcm5zIHx8IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBhdHRlcm5zKSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1QYXR0ZXJuKG5hbWUsIGNvbnRlbnQpO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHJlZ2lzdHJ5LnBhdHRlcm5zW25hbWVdO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4udHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycy51bnNoaWZ0KHBhdHRlcm4udHJpZ2dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWF0Y2hlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsQW5kTWUoXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgc2VsZWN0b3JzLm1hcCgoaXQpID0+IGl0LnRyaW0oKS5yZXBsYWNlKC8sJC8sIFwiXCIpKS5qb2luKFwiLFwiKVxuICAgICAgICApO1xuICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5maWx0ZXIoKGVsKSA9PiB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHBhdHRlcm5zOlxuICAgICAgICAgICAgLy8gLSB3aXRoIGNsYXNzIGBgLmRpc2FibGUtcGF0dGVybnNgYFxuICAgICAgICAgICAgLy8gLSB3cmFwcGVkIGluIGBgLmRpc2FibGUtcGF0dGVybnNgYCBlbGVtZW50c1xuICAgICAgICAgICAgLy8gLSB3cmFwcGVkIGluIGBgPHByZT5gYCBlbGVtZW50c1xuICAgICAgICAgICAgLy8gLSB3cmFwcGVkIGluIGBgPHRlbXBsYXRlPmBgIGVsZW1lbnRzXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICFlbC5tYXRjaGVzKFwiLmRpc2FibGUtcGF0dGVybnNcIikgJiZcbiAgICAgICAgICAgICAgICAhZWw/LnBhcmVudE5vZGU/LmNsb3Nlc3Q/LihcIi5kaXNhYmxlLXBhdHRlcm5zXCIpICYmXG4gICAgICAgICAgICAgICAgIWVsPy5wYXJlbnROb2RlPy5jbG9zZXN0Py4oXCJwcmVcIikgJiZcbiAgICAgICAgICAgICAgICAhZWw/LnBhcmVudE5vZGU/LmNsb3Nlc3Q/LihcInRlbXBsYXRlXCIpICYmIC8vIE5PVEU6IG5vdCBzdHJpY3RseSBuZWNlc3NhcnkuIFRlbXBsYXRlIGlzIGEgRG9jdW1lbnRGcmFnbWVudCBhbmQgbm90IHJlYWNoYWJsZSBleGNlcHQgZm9yIElFLlxuICAgICAgICAgICAgICAgICFlbC5tYXRjaGVzKFwiLmNhbnQtdG91Y2gtdGhpc1wiKSAmJiAvLyBCQkIuIFRPRE86IFJlbW92ZSB3aXRoIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICAgICAgICAgICAgICAhZWw/LnBhcmVudE5vZGU/LmNsb3Nlc3Q/LihcIi5jYW50LXRvdWNoLXRoaXNcIikgLy8gQkJCLiBUT0RPOiBSZW1vdmUgd2l0aCBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3YWxrIGxpc3QgYmFja3dhcmRzIGFuZCBpbml0aWFsaXplIHBhdHRlcm5zIGluc2lkZS1vdXQuXG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgbWF0Y2hlcy5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBhdHRlcm4obmFtZSwgZWwsIHRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcInBhdHRlcm5zLWxvYWRlZFwiKTtcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXIocGF0dGVybiwgbmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZSB8fCBwYXR0ZXJuLm5hbWU7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiUGF0dGVybiBsYWNrcyBhIG5hbWUuXCIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdpc3RyeS5wYXR0ZXJuc1tuYW1lXSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBBbHJlYWR5IGhhdmUgYSBwYXR0ZXJuIGNhbGxlZCAke25hbWV9LmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZ2lzdGVyIHBhdHRlcm4gdG8gYmUgdXNlZCBmb3Igc2Nhbm5pbmcgbmV3IGNvbnRlbnRcbiAgICAgICAgcmVnaXN0cnkucGF0dGVybnNbbmFtZV0gPSBwYXR0ZXJuO1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHBhdHRlcm4gYXMganF1ZXJ5IHBsdWdpblxuICAgICAgICBpZiAocGF0dGVybi5qcXVlcnlfcGx1Z2luKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5fbmFtZSA9IChcInBhdC1cIiArIG5hbWUpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgLy0oW2EtekEtWl0pL2csXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG1hdGNoLCBwMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgJC5mbltwbHVnaW5fbmFtZV0gPSB1dGlscy5qcXVlcnlQbHVnaW4ocGF0dGVybik7XG4gICAgICAgICAgICAvLyBCQkIgMjAxMi0xMi0xMCBhbmQgYWxzbyBmb3IgTW9ja3VwIHBhdHRlcm5zLlxuICAgICAgICAgICAgJC5mbltwbHVnaW5fbmFtZS5yZXBsYWNlKC9ecGF0LywgXCJwYXR0ZXJuXCIpXSA9ICQuZm5bcGx1Z2luX25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5kZWJ1ZyhgUmVnaXN0ZXJlZCBwYXR0ZXJuICR7bmFtZX1gLCBwYXR0ZXJuKTtcbiAgICAgICAgaWYgKHdpbmRvdy5fX3BhdHRlcm5zbGliX3JlZ2lzdHJ5X2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBPbmNlIHRoZSBmaXJzdCBpbml0aWFsaXphdGlvbiBoYXMgYmVlbiBkb25lLCBkbyBvbmx5IHNjYW4gZm9yXG4gICAgICAgICAgICAvLyBuZXdseSByZWdpc3RlcmVkIHBhdHRlcm5zLlxuICAgICAgICAgICAgcmVnaXN0cnkuc2Nhbihkb2N1bWVudC5ib2R5LCBbbmFtZV0pO1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBSZS1zY2FubmVkIGRvbSB3aXRoIG5ld2x5IHJlZ2lzdGVyZWQgcGF0dGVybiAke25hbWV9LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZWdpc3RyeTtcbiIsImltcG9ydCAkIGZyb20gXCJqcXVlcnlcIjtcbmltcG9ydCBkb20gZnJvbSBcIi4vZG9tXCI7XG5cbiQuZm4uc2FmZUNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgLy8gSUUgQlVHIDogUGxhY2Vob2xkZXIgdGV4dCBiZWNvbWVzIGFjdHVhbCB2YWx1ZSBhZnRlciBkZWVwIGNsb25lIG9uIHRleHRhcmVhXG4gICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy83ODE2MTIvcGxhY2Vob2xkZXItdGV4dC1iZWNvbWVzLWFjdHVhbC12YWx1ZS1hZnRlci1kZWVwLWNsb25lLW9uLXRleHRhcmVhXG4gICAgaWYgKHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudE1vZGUpIHtcbiAgICAgICAgJGNsb25lLmZpbmRJbmNsdXNpdmUoXCI6aW5wdXRbcGxhY2Vob2xkZXJdXCIpLmVhY2goZnVuY3Rpb24gKGksIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciAkaXRlbSA9ICQoaXRlbSk7XG4gICAgICAgICAgICBpZiAoJGl0ZW0uYXR0cihcInBsYWNlaG9sZGVyXCIpID09PSAkaXRlbS52YWwoKSkge1xuICAgICAgICAgICAgICAgICRpdGVtLnZhbChcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAkY2xvbmU7XG59O1xuXG4vLyBQcm9kdWN0aW9uIHN0ZXBzIG9mIEVDTUEtMjYyLCBFZGl0aW9uIDUsIDE1LjQuNC4xOFxuLy8gUmVmZXJlbmNlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjQuNC4xOFxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBULCBrO1xuICAgICAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIiB0aGlzIGlzIG51bGwgb3Igbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMS4gTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIFRvT2JqZWN0IHBhc3NpbmcgdGhlIHx0aGlzfCB2YWx1ZSBhcyB0aGUgYXJndW1lbnQuXG4gICAgICAgIHZhciBPID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAvLyAyLiBMZXQgbGVuVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCB0aGUgYXJndW1lbnQgXCJsZW5ndGhcIi5cbiAgICAgICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXG4gICAgICAgIHZhciBsZW4gPSBPLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgLy8gNC4gSWYgSXNDYWxsYWJsZShjYWxsYmFjaykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gU2VlOiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjExXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDUuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBUID0gdGhpc0FyZztcbiAgICAgICAgfVxuICAgICAgICAvLyA2LiBMZXQgayBiZSAwXG4gICAgICAgIGsgPSAwO1xuICAgICAgICAvLyA3LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW5cbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhciBrVmFsdWU7XG4gICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgVG9TdHJpbmcoaykuXG4gICAgICAgICAgICAvLyAgIFRoaXMgaXMgaW1wbGljaXQgZm9yIExIUyBvcGVyYW5kcyBvZiB0aGUgaW4gb3BlcmF0b3JcbiAgICAgICAgICAgIC8vIGIuIExldCBrUHJlc2VudCBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEhhc1Byb3BlcnR5IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXG4gICAgICAgICAgICAvLyAgIFRoaXMgc3RlcCBjYW4gYmUgY29tYmluZWQgd2l0aCBjXG4gICAgICAgICAgICAvLyBjLiBJZiBrUHJlc2VudCBpcyB0cnVlLCB0aGVuXG4gICAgICAgICAgICBpZiAoayBpbiBPKSB7XG4gICAgICAgICAgICAgICAgLy8gaS4gTGV0IGtWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgICAgICAgICAgIGtWYWx1ZSA9IE9ba107XG4gICAgICAgICAgICAgICAgLy8gaWkuIENhbGwgdGhlIENhbGwgaW50ZXJuYWwgbWV0aG9kIG9mIGNhbGxiYWNrIHdpdGggVCBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBsaXN0IGNvbnRhaW5pbmcga1ZhbHVlLCBrLCBhbmQgTy5cbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKFQsIGtWYWx1ZSwgaywgTyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkLiBJbmNyZWFzZSBrIGJ5IDEuXG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gOC4gcmV0dXJuIHVuZGVmaW5lZFxuICAgIH07XG59XG5cbnZhciBzaW5nbGVCb3VuZEpRdWVyeVBsdWdpbiA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBtZXRob2QsIG9wdGlvbnMpIHtcbiAgICAvKiBUaGlzIGlzIGEgalF1ZXJ5IHBsdWdpbiBmb3IgcGF0dGVybnMgd2hpY2ggYXJlIGludm9rZWQgT05DRSBGT1IgRUFDSFxuICAgICAqIG1hdGNoZWQgZWxlbWVudCBpbiB0aGUgRE9NLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBob3cgdGhlIE1vY2t1cC10eXBlIHBhdHRlcm5zIGJlaGF2ZS4gVGhleSBhcmUgY29uc3RydWN0b3JcbiAgICAgKiBmdW5jdGlvbnMgd2hpY2ggbmVlZCB0byBiZSBpbnZva2VkIG9uY2UgcGVyIGpRdWVyeS13cmFwcGVkIERPTSBub2RlXG4gICAgICogZm9yIGFsbCBET00gbm9kZXMgb24gd2hpY2ggdGhlIHBhdHRlcm4gYXBwbGllcy5cbiAgICAgKi9cbiAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICR0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0LFxuICAgICAgICAgICAgJGVsID0gJCh0aGlzKTtcbiAgICAgICAgcGF0ID0gcGF0dGVybi5pbml0KCRlbCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChwYXRbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgJC5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJNZXRob2QgXCIgKyBtZXRob2QgKyBcIiBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkuXCIgKyBwYXR0ZXJuLm5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRob2QuY2hhckF0KDApID09PSBcIl9cIikge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJNZXRob2QgXCIgKyBtZXRob2QgKyBcIiBpcyBwcml2YXRlIG9uIGpRdWVyeS5cIiArIHBhdHRlcm4ubmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0W21ldGhvZF0uYXBwbHkocGF0LCBbb3B0aW9uc10pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICR0aGlzO1xufTtcblxudmFyIHBsdXJhbEJvdW5kSlF1ZXJ5UGx1Z2luID0gZnVuY3Rpb24gKHBhdHRlcm4sIG1ldGhvZCwgb3B0aW9ucykge1xuICAgIC8qIFRoaXMgaXMgYSBqUXVlcnkgcGx1Z2luIGZvciBwYXR0ZXJucyB3aGljaCBhcmUgaW52b2tlZCBPTkNFIEZPUiBBTExcbiAgICAgKiBtYXRjaGVkIGVsZW1lbnRzIGluIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGhvdyB0aGUgdmFuaWxsYSBQYXR0ZXJuc2xpYi10eXBlIHBhdHRlcm5zIGJlaGF2ZS4gVGhleSBhcmVcbiAgICAgKiBzaW1wbGUgb2JqZWN0cyB3aXRoIGFuIGluaXQgbWV0aG9kIGFuZCB0aGlzIG1ldGhvZCBnZXRzIGNhbGxlZCBvbmNlXG4gICAgICogd2l0aCBhIGxpc3Qgb2YgalF1ZXJ5LXdyYXBwZWQgRE9NIG5vZGVzIG9uIHdoaWNoIHRoZSBwYXR0ZXJuXG4gICAgICogYXBwbGllcy5cbiAgICAgKi9cbiAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgaWYgKHBhdHRlcm5bbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm5bbWV0aG9kXS5hcHBseSgkdGhpcywgWyR0aGlzXS5jb25jYXQoW29wdGlvbnNdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVycm9yKFwiTWV0aG9kIFwiICsgbWV0aG9kICsgXCIgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LlwiICsgcGF0dGVybi5uYW1lKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4uaW5pdC5hcHBseSgkdGhpcywgWyR0aGlzXS5jb25jYXQoW29wdGlvbnNdKSk7XG4gICAgfVxuICAgIHJldHVybiAkdGhpcztcbn07XG5cbnZhciBqcXVlcnlQbHVnaW4gPSBmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICgkdGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG1ldGhvZDtcbiAgICAgICAgICAgIG1ldGhvZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmdsZUJvdW5kSlF1ZXJ5UGx1Z2luLmNhbGwodGhpcywgcGF0dGVybiwgbWV0aG9kLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwbHVyYWxCb3VuZEpRdWVyeVBsdWdpbi5jYWxsKHRoaXMsIHBhdHRlcm4sIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiAhIW9iaik7XG59XG5cbi8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICAgIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICB2YXIgc291cmNlLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG4vLyBFTkQ6IFRha2VuIGZyb20gVW5kZXJzY29yZS5qcyB1bnRpbCBoZXJlLlxuXG5mdW5jdGlvbiByZWJhc2VVUkwoYmFzZSwgdXJsKSB7XG4gICAgYmFzZSA9IG5ldyBVUkwoYmFzZSwgd2luZG93LmxvY2F0aW9uKS5ocmVmOyAvLyBJZiBiYXNlIGlzIHJlbGF0aXZlIG1ha2UgaXQgYWJzb2x1dGUuXG4gICAgaWYgKHVybC5pbmRleE9mKFwiOi8vXCIpICE9PSAtMSB8fCB1cmxbMF0gPT09IFwiL1wiIHx8IHVybC5pbmRleE9mKFwiZGF0YTpcIikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2Uuc2xpY2UoMCwgYmFzZS5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHVybDtcbn1cblxuZnVuY3Rpb24gZmluZExhYmVsKGlucHV0KSB7XG4gICAgdmFyICRsYWJlbDtcbiAgICBmb3IgKFxuICAgICAgICB2YXIgbGFiZWwgPSBpbnB1dC5wYXJlbnROb2RlO1xuICAgICAgICBsYWJlbCAmJiBsYWJlbC5ub2RlVHlwZSAhPT0gMTE7XG4gICAgICAgIGxhYmVsID0gbGFiZWwucGFyZW50Tm9kZVxuICAgICkge1xuICAgICAgICBpZiAobGFiZWwudGFnTmFtZSA9PT0gXCJMQUJFTFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlucHV0LmlkKSB7XG4gICAgICAgICRsYWJlbCA9ICQoJ2xhYmVsW2Zvcj1cIicgKyBpbnB1dC5pZCArICdcIl0nKTtcbiAgICB9XG4gICAgaWYgKCRsYWJlbCAmJiAkbGFiZWwubGVuZ3RoID09PSAwICYmIGlucHV0LmZvcm0pIHtcbiAgICAgICAgJGxhYmVsID0gJCgnbGFiZWxbZm9yPVwiJyArIGlucHV0Lm5hbWUgKyAnXCJdJywgaW5wdXQuZm9ybSk7XG4gICAgfVxuICAgIGlmICgkbGFiZWwgJiYgJGxhYmVsLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJGxhYmVsWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyMzk5OS9ob3ctdG8tdGVsbC1pZi1hLWRvbS1lbGVtZW50LWlzLXZpc2libGUtaW4tdGhlLWN1cnJlbnQtdmlld3BvcnRcbmZ1bmN0aW9uIGVsZW1lbnRJblZpZXdwb3J0KGVsKSB7XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIHZXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY0VsLmNsaWVudFdpZHRoLFxuICAgICAgICB2SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY0VsLmNsaWVudEhlaWdodDtcblxuICAgIGlmIChyZWN0LnJpZ2h0IDwgMCB8fCByZWN0LmJvdHRvbSA8IDAgfHwgcmVjdC5sZWZ0ID4gdldpZHRoIHx8IHJlY3QudG9wID4gdkhlaWdodClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBUYWtlbiBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQ0NjE3MC9lc2NhcGUtc3RyaW5nLWZvci11c2UtaW4tamF2YXNjcmlwdC1yZWdleFxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csIFwiXFxcXCQmXCIpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzc2VzIGZyb20gYSBsaXN0IG9mIHRhcmdldHMgaWYgdGhleSBtYXRjaCBhIHNwZWNpZmljIHBhdHRlcm4uXG4gKlxuICogQHBhcmFtIHtOb2RlLCBOb2RlTGlzdH0gdGFyZ2V0czogRG9tIE5vZGUgb3IgTm9kZUxpc3Qgd2hlcmUgdGhlIGNsYXNzZXMgc2hvdWxkIGJlIHJlbW92ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlczogU3RyaW5nIG1hdGNoaW5nIGNsYXNzZXMgdG8gYmUgcmVtb3ZlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGFkZCBhIFwiKlwiIGFzIHdpbGRjYXJkIHRvIHNlYXJjaCBmb3IgY2xhc3NlcyB0byBiZSByZW1vdmVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIEUuZy4gXCJpY29uLSotYWxlcnRcIiB0byByZW1vdmUgYW55IG9mIFwiaWNvbi0xLWFsZXJ0IGljb24tMi1hbGVydFwiLlxuICpcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9OiBUaGlzIG1ldGhvZCBkaXJlY3RseSBvcGVyYXRlcyBvbiB0aGUgdGFyZ2V0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlV2lsZGNhcmRDbGFzcyh0YXJnZXRzLCBjbGFzc2VzKSB7XG4gICAgdGFyZ2V0cyA9IHV0aWxzLmVuc3VyZUFycmF5KHRhcmdldHMpO1xuXG4gICAgaWYgKGNsYXNzZXMuaW5kZXhPZihcIipcIikgPT09IC0xKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzZXMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG1hdGNoZXIgPSBjbGFzc2VzLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICBtYXRjaGVyID0gbWF0Y2hlci5yZXBsYWNlKC9bKl0vZywgXCIuKlwiKTtcbiAgICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBtYXRjaGVyICsgXCIkXCIpO1xuXG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzX2xpc3QgPSAodGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICBpZiAoIWNsYXNzX2xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvayA9IGNsYXNzX2xpc3QuZmlsdGVyKChpdCkgPT4gIW1hdGNoZXIudGVzdChpdCkpO1xuICAgICAgICAgICAgaWYgKG9rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBvay5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzVmFsdWUoZWwpIHtcbiAgICBpZiAoZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiKSB7XG4gICAgICAgIGlmIChlbC50eXBlID09PSBcImNoZWNrYm94XCIgfHwgZWwudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuY2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWwudmFsdWUgIT09IFwiXCI7XG4gICAgfVxuICAgIGlmIChlbC50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gICAgICAgIHJldHVybiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMTtcbiAgICB9XG4gICAgaWYgKGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICByZXR1cm4gZWwudmFsdWUgIT09IFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgaGlkZU9yU2hvdyA9IChub2RlcywgdmlzaWJsZSwgb3B0aW9ucywgcGF0dGVybl9uYW1lKSA9PiB7XG4gICAgbm9kZXMgPSBkb20udG9Ob2RlQXJyYXkobm9kZXMpO1xuXG4gICAgY29uc3QgdHJhbnNpdGlvbnMgPSB7XG4gICAgICAgIG5vbmU6IHsgaGlkZTogXCJoaWRlXCIsIHNob3c6IFwic2hvd1wiIH0sXG4gICAgICAgIGZhZGU6IHsgaGlkZTogXCJmYWRlT3V0XCIsIHNob3c6IFwiZmFkZUluXCIgfSxcbiAgICAgICAgc2xpZGU6IHsgaGlkZTogXCJzbGlkZVVwXCIsIHNob3c6IFwic2xpZGVEb3duXCIgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgZHVyYXRpb24gPVxuICAgICAgICBvcHRpb25zLnRyYW5zaXRpb24gPT09IFwiY3NzXCIgfHwgb3B0aW9ucy50cmFuc2l0aW9uID09PSBcIm5vbmVcIlxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IG9wdGlvbnMuZWZmZWN0LmR1cmF0aW9uO1xuXG4gICAgY29uc3Qgb25fY29tcGxldGUgPSAoZWwpID0+IHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcImluLXByb2dyZXNzXCIpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKHZpc2libGUgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpO1xuICAgICAgICAkKGVsKS50cmlnZ2VyKFwicGF0LXVwZGF0ZVwiLCB7XG4gICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuX25hbWUsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBcImNvbXBsZXRlXCIsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IGVsIG9mIG5vZGVzKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJ2aXNpYmxlXCIpO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwiaW4tcHJvZ3Jlc3NcIik7XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gdHJhbnNpdGlvbnNbb3B0aW9ucy50cmFuc2l0aW9uXTtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJpbi1wcm9ncmVzc1wiKTtcbiAgICAgICAgICAgICQoZWwpLnRyaWdnZXIoXCJwYXQtdXBkYXRlXCIsIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuX25hbWUsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogXCJzdGFydFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKGVsKVt2aXNpYmxlID8gdC5zaG93IDogdC5oaWRlXSh7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5lZmZlY3QuZWFzaW5nLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiBvbl9jb21wbGV0ZShlbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gIT09IFwiY3NzXCIpIHtcbiAgICAgICAgICAgICAgICBkb21bdmlzaWJsZSA/IFwic2hvd1wiIDogXCJoaWRlXCJdKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uX2NvbXBsZXRlKGVsKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGFkZFVSTFF1ZXJ5UGFyYW1ldGVyKGZ1bGxVUkwsIHBhcmFtLCB2YWx1ZSkge1xuICAgIC8qIFVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkICg/PVxcPSkgdG8gZmluZCB0aGUgZ2l2ZW4gcGFyYW1ldGVyLFxuICAgICAqIHByZWNlZGVkIGJ5IGEgPyBvciAmLCBhbmQgZm9sbG93ZWQgYnkgYSA9IHdpdGggYSB2YWx1ZSBhZnRlclxuICAgICAqIHRoYW4gKHVzaW5nIGEgbm9uLWdyZWVkeSBzZWxlY3RvcikgYW5kIHRoZW4gZm9sbG93ZWQgYnlcbiAgICAgKiBhICYgb3IgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxuICAgICAqXG4gICAgICogVGFrZW4gZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc2NDAyNzAvYWRkaW5nLW1vZGlmeS1xdWVyeS1zdHJpbmctZ2V0LXZhcmlhYmxlcy1pbi1hLXVybC13aXRoLWphdmFzY3JpcHRcbiAgICAgKi9cbiAgICB2YXIgdmFsID0gbmV3IFJlZ0V4cChcIihcXFxcP3xcXFxcJilcIiArIHBhcmFtICsgXCI9Lio/KD89KCZ8JCkpXCIpLFxuICAgICAgICBwYXJ0cyA9IGZ1bGxVUkwudG9TdHJpbmcoKS5zcGxpdChcIiNcIiksXG4gICAgICAgIHVybCA9IHBhcnRzWzBdLFxuICAgICAgICBoYXNoID0gcGFydHNbMV0sXG4gICAgICAgIHFzdHJpbmcgPSAvXFw/LiskLyxcbiAgICAgICAgbmV3VVJMID0gdXJsO1xuICAgIC8vIENoZWNrIGlmIHRoZSBwYXJhbWV0ZXIgZXhpc3RzXG4gICAgaWYgKHZhbC50ZXN0KHVybCkpIHtcbiAgICAgICAgLy8gaWYgaXQgZG9lcywgcmVwbGFjZSBpdCwgdXNpbmcgdGhlIGNhcHR1cmVkIGdyb3VwXG4gICAgICAgIC8vIHRvIGRldGVybWluZSAmIG9yID8gYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICBuZXdVUkwgPSB1cmwucmVwbGFjZSh2YWwsIFwiJDFcIiArIHBhcmFtICsgXCI9XCIgKyB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChxc3RyaW5nLnRlc3QodXJsKSkge1xuICAgICAgICAvLyBvdGhlcndpc2UsIGlmIHRoZXJlIGlzIGEgcXVlcnkgc3RyaW5nIGF0IGFsbFxuICAgICAgICAvLyBhZGQgdGhlIHBhcmFtIHRvIHRoZSBlbmQgb2YgaXRcbiAgICAgICAgbmV3VVJMID0gdXJsICsgXCImXCIgKyBwYXJhbSArIFwiPVwiICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGhlcmUncyBubyBxdWVyeSBzdHJpbmcsIGFkZCBvbmVcbiAgICAgICAgbmV3VVJMID0gdXJsICsgXCI/XCIgKyBwYXJhbSArIFwiPVwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChoYXNoKSB7XG4gICAgICAgIG5ld1VSTCArPSBcIiNcIiArIGhhc2g7XG4gICAgfVxuICAgIHJldHVybiBuZXdVUkw7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZU9iamVjdHMob2Jqcykge1xuICAgIC8qIEdpdmVuIGFuIGFycmF5IG9mIG9iamVjdHMsIHJlbW92ZSBhbnkgZHVwbGljYXRlIG9iamVjdHMgd2hpY2ggbWlnaHRcbiAgICAgKiBiZSBwcmVzZW50LlxuICAgICAqL1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICByZXR1cm4gdGhpc1trXSA9PT0gdjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG9ianMucmVkdWNlKGZ1bmN0aW9uIChsaXN0LCBuZXh0X29iaikge1xuICAgICAgICBsZXQgaXNfZHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIGxpc3QpIHtcbiAgICAgICAgICAgIGlzX2R1cGxpY2F0ZSA9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKG5leHRfb2JqKS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgKGl0KSA9PiAhY29tcGFyYXRvci5iaW5kKG5leHRfb2JqKShpdFswXSwgaXRbMV0pXG4gICAgICAgICAgICAgICAgKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc19kdXBsaWNhdGUpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChuZXh0X29iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBtZXJnZVN0YWNrKHN0YWNrLCBsZW5ndGgpIHtcbiAgICAvKiBHaXZlbiBhIGxpc3Qgb2YgbGlzdHMgb2Ygb2JqZWN0cyAod2hpY2ggZm9yIGJyZXZpdHkgd2UgY2FsbCBhIHN0YWNrKSxcbiAgICAgKiByZXR1cm4gYSBsaXN0IG9mIG9iamVjdHMgd2hlcmUgZWFjaCBvYmplY3QgaXMgdGhlIG1lcmdlIG9mIGFsbCB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIG9yaWdpbmFsIG9iamVjdHMgYXQgdGhhdCBwYXJ0aWN1bGFyIGluZGV4LlxuICAgICAqXG4gICAgICogSWYgYSBjZXJ0YWluIHN1Yi1saXN0IGRvZXNuJ3QgaGF2ZSBhbiBvYmplY3QgYXQgdGhhdCBwYXJ0aWN1bGFyXG4gICAgICogaW5kZXgsIHRoZSBsYXN0IG9iamVjdCBpbiB0aGF0IGxpc3QgaXMgbWVyZ2VkLlxuICAgICAqL1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7fSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZnJhbWUgb2Ygc3RhY2spIHtcbiAgICAgICAgY29uc3QgZnJhbWVfbGVuZ3RoID0gZnJhbWUubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBsZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgcmVzdWx0c1t4XSA9ICQuZXh0ZW5kKFxuICAgICAgICAgICAgICAgIHJlc3VsdHNbeF0gfHwge30sXG4gICAgICAgICAgICAgICAgZnJhbWVbeCA+IGZyYW1lX2xlbmd0aCA/IGZyYW1lX2xlbmd0aCA6IHhdXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsLCBwYXJ0aWFsID0gZmFsc2UsIG9mZnNldCA9IDApIHtcbiAgICAvKiByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBpcyB2aXNpYmxlIHRvIHRoZSB1c2VyIGllLiBpcyBpbiB0aGUgdmlld3BvcnQuXG4gICAgICogU2V0dGluZyBwYXJ0aWFsIHBhcmFtZXRlciB0byB0cnVlLCB3aWxsIG9ubHkgY2hlY2sgaWYgYSBwYXJ0IG9mIHRoZSBlbGVtZW50IGlzIHZpc2libGVcbiAgICAgKiBpbiB0aGUgdmlld3BvcnQsIHNwZWNpZmljYWxseSB0aGF0IHNvbWUgcGFydCBvZiB0aGF0IGVsZW1lbnQgaXMgdG91Y2hpbmcgdGhlIHRvcCBwYXJ0XG4gICAgICogb2YgdGhlIHZpZXdwb3J0LiBUaGlzIG9ubHkgYXBwbGllcyB0byB0aGUgdmVydGljYWwgZGlyZWN0aW9uLCBpZS4gZG9lc250IGNoZWNrIHBhcnRpYWxcbiAgICAgKiB2aXNpYmlsaXR5IGZvciBob3Jpem9udGFsIHNjcm9sbGluZ1xuICAgICAqIHNvbWUgY29kZSB0YWtlbiBmcm9tOlxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIzOTk5L2hvdy10by10ZWxsLWlmLWEtZG9tLWVsZW1lbnQtaXMtdmlzaWJsZS1pbi10aGUtY3VycmVudC12aWV3cG9ydC83NTU3NDMzIzc1NTc0MzNcbiAgICAgKi9cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiAkKSB7XG4gICAgICAgIGVsID0gZWxbMF07XG4gICAgfVxuXG4gICAgY29uc3QgcmVjID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcmVjX3ZhbHVlcyA9IFtyZWMudG9wLCByZWMuYm90dG9tLCByZWMubGVmdCwgcmVjLnJpZ2h0XTtcblxuICAgIGlmIChyZWNfdmFsdWVzLmV2ZXJ5KCh2YWwpID0+IHZhbCA9PT0gMCkpIHtcbiAgICAgICAgLy8gaWYgZXZlcnkgcHJvcGVydHkgb2YgcmVjIGlzIDAsIHRoZSBlbGVtZW50IGlzIGludmlzaWJsZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocGFydGlhbCkge1xuICAgICAgICAvLyB3aGVuIHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIChpbiB0aGUgdmVydGljYWwgY2FzZSlcbiAgICAgICAgLy8gbmVnYXRpdmUgbWVhbnMgYWJvdmUgdG9wIG9mIHZpZXdwb3J0LCBwb3NpdGl2ZSBtZWFucyBiZWxvdyB0b3Agb2Ygdmlld3BvcnRcbiAgICAgICAgLy8gdGhlcmVmb3JlIGZvciBwYXJ0IG9mIHRoZSBlbGVtZW50IHRvIGJlIHRvdWNoaW5nIG9yIGNyb3NzaW5nIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0XG4gICAgICAgIC8vIHJlYy50b3AgbXVzdCA8PSAwIGFuZCByZWMuYm90dG9tIG11c3QgPj0gMFxuICAgICAgICAvLyBhbiBvcHRpb25hbCB0b2xlcmFuY2Ugb2Zmc2V0IGNhbiBiZSBhZGRlZCBmb3Igd2hlbiB0aGUgZGVzaXJlZCBlbGVtZW50IGlzIG5vdCBleGFjdGx5XG4gICAgICAgIC8vIHRvdWNpbmcgdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgYnV0IG5lZWRzIHRvIGJlIGNvbnNpZGVyZWQgYXMgdG91Y2hpbmcuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWMudG9wIDw9IDAgKyBvZmZzZXQgJiYgcmVjLmJvdHRvbSA+PSAwICsgb2Zmc2V0XG4gICAgICAgICAgICAvLyhyZWMudG9wID49IDArb2Zmc2V0ICYmIHJlYy50b3AgPD0gd2luZG93LmlubmVySGVpZ2h0KSAvLyB0aGlzIGNoZWNrcyBpZiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgLy8gdG91Y2hlcyBib3R0b20gcGFydCBvZiB2aWV3cG9ydFxuICAgICAgICAgICAgLy8gWFhYIGRvIHdlIHdhbnQgdG8gaW5jbHVkZSBhIGNoZWNrIGZvciB0aGUgcGFkZGluZyBvZiBhbiBlbGVtZW50P1xuICAgICAgICAgICAgLy8gdXNpbmcgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5wYWRkaW5nVG9wXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBlbnRpcmUgZWxlbWVudCBpcyBjb21wbGV0ZWx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVjLnRvcCA+PSAwICYmXG4gICAgICAgICAgICByZWMubGVmdCA+PSAwICYmXG4gICAgICAgICAgICByZWMuYm90dG9tIDw9XG4gICAgICAgICAgICAgICAgKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSAmJlxuICAgICAgICAgICAgcmVjLnJpZ2h0IDw9ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWUodGltZSkge1xuICAgIHZhciBtID0gL14oXFxkKyg/OlxcLlxcZCspPylcXHMqKFxcdyopLy5leGVjKHRpbWUpO1xuICAgIGlmICghbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRpbWVcIik7XG4gICAgfVxuICAgIHZhciBhbW91bnQgPSBwYXJzZUZsb2F0KG1bMV0pO1xuICAgIHN3aXRjaCAobVsyXSkge1xuICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYW1vdW50ICogMTAwMCk7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhbW91bnQgKiAxMDAwICogNjApO1xuICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGFtb3VudCk7XG4gICAgfVxufVxuXG4vLyBSZXR1cm4gYSBqUXVlcnkgb2JqZWN0IHdpdGggZWxlbWVudHMgcmVsYXRlZCB0byBhbiBpbnB1dCBlbGVtZW50LlxuZnVuY3Rpb24gZmluZFJlbGF0aXZlcyhlbCkge1xuICAgIHZhciAkZWwgPSAkKGVsKSxcbiAgICAgICAgJHJlbGF0aXZlcyA9ICQoZWwpLFxuICAgICAgICAkbGFiZWwgPSAkKCk7XG5cbiAgICAkcmVsYXRpdmVzID0gJHJlbGF0aXZlcy5hZGQoJGVsLmNsb3Nlc3QoXCJsYWJlbFwiKSk7XG4gICAgJHJlbGF0aXZlcyA9ICRyZWxhdGl2ZXMuYWRkKCRlbC5jbG9zZXN0KFwiZmllbGRzZXRcIikpO1xuXG4gICAgaWYgKGVsLmlkKSAkbGFiZWwgPSAkKFwibGFiZWxbZm9yPSdcIiArIGVsLmlkICsgXCInXVwiKTtcbiAgICBpZiAoISRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRmb3JtID0gJGVsLmNsb3Nlc3QoXCJmb3JtXCIpO1xuICAgICAgICBpZiAoISRmb3JtLmxlbmd0aCkgJGZvcm0gPSAkKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAkbGFiZWwgPSAkZm9ybS5maW5kKFwibGFiZWxbZm9yPSdcIiArIGVsLm5hbWUgKyBcIiddXCIpO1xuICAgIH1cbiAgICAkcmVsYXRpdmVzID0gJHJlbGF0aXZlcy5hZGQoJGxhYmVsKTtcbiAgICByZXR1cm4gJHJlbGF0aXZlcztcbn1cblxuZnVuY3Rpb24gZ2V0X2JvdW5kcyhlbCkge1xuICAgIC8vIFJldHVybiBib3VuZHMgb2YgYW4gZWxlbWVudCB3aXRoIGl0J3MgdmFsdWVzIHJvdW5kZWQgYW5kIGNvbnZlcnRlZCB0byBpbnRzLlxuICAgIGNvbnN0IGJvdW5kcyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBhcnNlSW50KE1hdGgucm91bmQoYm91bmRzLngpLCAxMCkgfHwgMCxcbiAgICAgICAgeTogcGFyc2VJbnQoTWF0aC5yb3VuZChib3VuZHMueSksIDEwKSB8fCAwLFxuICAgICAgICB0b3A6IHBhcnNlSW50KE1hdGgucm91bmQoYm91bmRzLnRvcCksIDEwKSB8fCAwLFxuICAgICAgICBib3R0b206IHBhcnNlSW50KE1hdGgucm91bmQoYm91bmRzLmJvdHRvbSksIDEwKSB8fCAwLFxuICAgICAgICBsZWZ0OiBwYXJzZUludChNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0KSwgMTApIHx8IDAsXG4gICAgICAgIHJpZ2h0OiBwYXJzZUludChNYXRoLnJvdW5kKGJvdW5kcy5yaWdodCksIDEwKSB8fCAwLFxuICAgICAgICB3aWR0aDogcGFyc2VJbnQoTWF0aC5yb3VuZChib3VuZHMud2lkdGgpLCAxMCkgfHwgMCxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUludChNYXRoLnJvdW5kKGJvdW5kcy5oZWlnaHQpLCAxMCkgfHwgMCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja0lucHV0U3VwcG9ydCh0eXBlLCBpbnZhbGlkX3ZhbHVlKSB7XG4gICAgLyogQ2hlY2sgaW5wdXQgdHlwZSBzdXBwb3J0LlxuICAgICAqICBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDE5OTMwNi8xMzM3NDc0XG4gICAgICovXG4gICAgbGV0IHN1cHBvcnQgPSBmYWxzZTtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHR5cGUpO1xuICAgIHN1cHBvcnQgPSBpbnB1dC50eXBlID09IHR5cGU7XG5cbiAgICBpZiAoaW52YWxpZF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnB1dCB0eXBlIFVJIHN1cHBvcnRcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgaW52YWxpZF92YWx1ZSk7XG4gICAgICAgIHN1cHBvcnQgPSBpbnB1dC52YWx1ZSAhPT0gaW52YWxpZF92YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnQ7XG59XG5cbmNvbnN0IGNoZWNrQ1NTRmVhdHVyZSA9IChhdHRyaWJ1dGUsIHZhbHVlLCB0YWcgPSBcImRpdlwiKSA9PiB7XG4gICAgLyogQ2hlY2sgZm9yIGJyb3dzZXIgc3VwcG9ydCBvZiBzcGVjaWZpYyBDU1MgZmVhdHVyZS5cbiAgICAgKi9cbiAgICB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgbGV0IHN1cHBvcnRlZCA9IHRhZy5zdHlsZVthdHRyaWJ1dGVdICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKHN1cHBvcnRlZCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhZy5zdHlsZVthdHRyaWJ1dGVdID0gdmFsdWU7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRhZy5zdHlsZVthdHRyaWJ1dGVdID09PSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbn07XG5cbmNvbnN0IGFuaW1hdGlvbl9mcmFtZSA9ICgpID0+IHtcbiAgICAvLyBSZXR1cm4gcHJvbWlzZSB0byBhd2FpdCBuZXh0IHJlcGFpbnQgY3ljbGVcbiAgICAvLyBVc2UgaXQgaW4geW91ciBhc3luYyBmdW5jdGlvbiBsaWtlIHNvOiBgYGF3YWl0IHV0aWxzLmFuaW1hdGlvbl9mcmFtZSgpYGBcbiAgICAvLyBGcm9tOiBodHRwOi8vd3d3LmFsYmVydGxvYm8uY29tL2ZyYWN0YWxzL2FzeW5jLWF3YWl0LXJlcXVlc3RhbmltYXRpb25mcmFtZS1idWRkaGFicm90XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpO1xufTtcblxuY29uc3QgdGltZW91dCA9IChtcykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufTtcblxuY29uc3QgZGVib3VuY2UgPSAoZnVuYywgbXMsIHRpbWVyID0geyB0aW1lcjogbnVsbCB9KSA9PiB7XG4gICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAgIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgICAvLyBOIG1pbGxpc2Vjb25kcy5cbiAgICAvLyBGcm9tOiBodHRwczovL3VuZGVyc2NvcmVqcy5vcmcvI2RlYm91bmNlXG4gICAgLy9cbiAgICAvLyBNYWtlIHN1cmUgdG8gaW5pdGlhbGl6ZSBgYGRlYm91bmNlYGAgb25seSBvbmNlIHBlciB0by1iZS1kZWJvdW5jZWRcbiAgICAvLyBmdW5jdGlvbiB0byBub3QgcmVpbml0aWFsaXplIHRoZSB0aW1lciBlYWNoIHRpbWUgYW5kIGRlYm91bmNlIG5vdCBiZWluZ1xuICAgIC8vIGFibGUgdG8gY2FuY2VsIHByZXZpb3VzZSBydW5zLlxuICAgIC8vXG4gICAgLy8gUGFzcyBhIG1vZHVsZS1nbG9iYWwgdGltZXIgYXMgYW4gb2JqZWN0IGBgeyB0aW1lcjogbnVsbCB9YGAgaWYgeW91IHdhbnRcbiAgICAvLyB0byBhbHNvIGNhbmNlbCBkZWJvdW5jZWQgZnVuY3Rpb25zIGZyb20gb3RoZXIgcGF0dGVybi1pbnZvY2F0aW9ucy5cbiAgICAvL1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRpbWVyLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpLCBtcyk7XG4gICAgfTtcbn07XG5cbmNvbnN0IGlzSUUgPSAoKSA9PiB7XG4gICAgLy8gU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTg1MTc2OS8xMzM3NDc0XG4gICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgNi0xMVxuICAgIHJldHVybiAvKkBjY19vbiFAKi8gZmFsc2UgfHwgISFkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59O1xuXG5jb25zdCBqcVRvTm9kZSA9IChlbCkgPT4ge1xuICAgIC8vIFJldHVybiBhIERPTSBub2RlIGlmIGEgalF1ZXJ5IG5vZGUgd2FzIHBhc3NlZC5cbiAgICBpZiAoZWwuanF1ZXJ5KSB7XG4gICAgICAgIGVsID0gZWxbMF07XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn07XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBhbiBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHthbnl9IGl0OiBUaGUgb2JqZWN0IHdoaWNoIG5lZWRzIHRvIGJlIHdyYXBwZWQgaW4gYW4gYXJyYXkgb3IgcmV0dXJuZWQgYXMgaXMgaWYgaXQgaXMgaXRlcmFibGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlX2FycmF5OiBJZiB0aGUgb2JqZWN0IGlzIGl0ZXJhYmxlIGJ1dCBub3QgYW4gQXJyYXksIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgKGUuZy4gRm9yIGpRdWVyeSBpdGVtcyBvciBOb2RlTGlzdCBvYmplY3RzKS5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9OiBSZXR1cm5zIHRoZSBvYmplY3Qgd3JhcHBlZCBpbiBhbiBBcnJheSwgZXhwYW5kZWQgdG8gYW4gQXJyYXkgb3IgYXMtaXMgaWYgaXQgaXMgYWxyZWFkeSBpdGVyYWJsZS5cbiAqL1xuY29uc3QgZW5zdXJlQXJyYXkgPSAoaXQsIGZvcmNlX2FycmF5KSA9PiB7XG4gICAgLy8gRW5zdXJlIHRvIHJldHVybiBhbHdheXMgYW4gYXJyYXlcbiAgICBjb25zdCBhcnJheV9saWtlID0gISEoXG4gICAgICAgIE5vZGVMaXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGl0KSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICBBcnJheS5pc0FycmF5KGl0KSB8fFxuICAgICAgICBpdC5qcXVlcnlcbiAgICApO1xuICAgIHJldHVybiBhcnJheV9saWtlID8gKGZvcmNlX2FycmF5ID8gWy4uLml0XSA6IGl0KSA6IFtpdF07XG59O1xuXG5jb25zdCBsb2NhbGl6ZWRfaXNvZGF0ZSA9IChkYXRlKSA9PiB7XG4gICAgLy8gUmV0dXJuIGEgaXNvIGRhdGUgKGRhdGUgb25seSkgaW4gdGhlIGN1cnJlbnQgdGltZXpvbmUgaW5zdGVhZCBvZiBhXG4gICAgLy8gVVRDIElTTyA4NjAxIGRhdGUrdGltZSBjb21wb25lbnQgd2hpY2ggdG9JU09TdHJpbmcgcmV0dXJucy5cblxuICAgIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIGNvbnN0IG1vbnRoID0gKGRhdGUuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcblxuICAgIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1gO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIEhUTUwgcmVzZXJ2ZWQgY2hhcmFjdGVycyB3aXRoIGh0bWwgZW50aXRpZXMgdG8gYWRkIEhUTUwgZm9yIHVzZXJcbiAqIGVkaXRpbmcgdG8gZS5nLiBhIHRleHRhcmVhIG9yIGEgY29udGVudGVkaXRhYmxlLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9HbG9zc2FyeS9FbnRpdHkjcmVzZXJ2ZWRfY2hhcmFjdGVyc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIC0gVGhlIEhUTUwgc3RyaW5nIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFJldHVybnMgdGhlIGVzY2FwZWQgaHRtbCBzdHJpbmc6XG4gKiAgICAgICAgICAgICAgICAgICAgIGBgJmBgIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBgYCZhbXA7YGAuXG4gKiAgICAgICAgICAgICAgICAgICAgIGBgPGBgIHdpbGwgYmUgcmVwYWxjZWQgd2l0aCBgYCZsdDtgYCxcbiAqICAgICAgICAgICAgICAgICAgICAgYGA+YGAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGBgJmd0O2BgLFxuICogICAgICAgICAgICAgICAgICAgICBgYFwiYGAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGBgJnF1b3Q7YGAuXG4gKi9cbmNvbnN0IGVzY2FwZV9odG1sID0gKGh0bWwpID0+IHtcbiAgICByZXR1cm4gKGh0bWwgfHwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKSAvLyBuZWVkcyB0byBiZSBmaXJzdCFcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXG4gICAgICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxuICAgICAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIik7XG59O1xuXG4vKipcbiAqIFJldHVybiB1bmVzY2FwZWQsIHJhdyBIVE1MIGZyb20gYW4gZXNjYXBlZCBIVE1MICBzdHJpbmcuXG4gKlxuICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0VudGl0eSNyZXNlcnZlZF9jaGFyYWN0ZXJzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVzY2FwZWRfaHRtbCAtIFRoZSBIVE1MIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gLSBSZXR1cm5zIHRoZSBlc2NhcGVkIGh0bWwgc3RyaW5nOlxuICogICAgICAgICAgICAgICAgICAgICBgYCZhbXA7YGAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGBgJmBgLFxuICogICAgICAgICAgICAgICAgICAgICBgYCZsdDtgYCB3aWxsIGJlIHJlcGFsY2VkIHdpdGggYGA8YGAsXG4gKiAgICAgICAgICAgICAgICAgICAgIGBgJmd0O2BgIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBgYD5gYCxcbiAqICAgICAgICAgICAgICAgICAgICAgYGAmcXVvdDtgYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYGBcImBgLlxuICovXG5jb25zdCB1bmVzY2FwZV9odG1sID0gKGVzY2FwZWRfaHRtbCkgPT4ge1xuICAgIHJldHVybiAoZXNjYXBlZF9odG1sIHx8IFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKC8mYW1wOy9nLCBcIiZcIilcbiAgICAgICAgLnJlcGxhY2UoLyZsdDsvZywgXCI8XCIpXG4gICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKVxuICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSwgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgSVNPIDg2MDEgZGF0ZS90aW1lIHN0cmluZyB3aXRoIG9yIHdpdGhvdXQgYW4gb3B0aW9uYWwgdGltZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gVGhlIGRhdGUvdGltZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9uYWxfdGltZT1mYWxzZV0gLSBUcnVlLCBpZiB0aW1lIGNvbXBvbmVudCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gVHJ1ZSwgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgRGF0ZSBzdHJpbmcuIEZhbHNlIGlmIG5vdC5cbiAqL1xuY29uc3QgaXNfaXNvX2RhdGVfdGltZSA9ICh2YWx1ZSwgb3B0aW9uYWxfdGltZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgcmVfZGF0ZV90aW1lID0gb3B0aW9uYWxfdGltZVxuICAgICAgICA/IC9eXFxkezR9LVswMV1cXGQtWzAtM11cXGQoVFswLTJdXFxkOlswLTVdXFxkKT8kL1xuICAgICAgICA6IC9eXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQkLztcbiAgICByZXR1cm4gcmVfZGF0ZV90aW1lLnRlc3QodmFsdWUpO1xufTtcblxudmFyIHV0aWxzID0ge1xuICAgIC8vIHBhdHRlcm4gcGltcGluZyAtIG93biBtb2R1bGU/XG4gICAganF1ZXJ5UGx1Z2luOiBqcXVlcnlQbHVnaW4sXG4gICAgZXNjYXBlUmVnRXhwOiBlc2NhcGVSZWdFeHAsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIHJlYmFzZVVSTDogcmViYXNlVVJMLFxuICAgIGZpbmRMYWJlbDogZmluZExhYmVsLFxuICAgIGVsZW1lbnRJblZpZXdwb3J0OiBlbGVtZW50SW5WaWV3cG9ydCxcbiAgICByZW1vdmVXaWxkY2FyZENsYXNzOiByZW1vdmVXaWxkY2FyZENsYXNzLFxuICAgIGhpZGVPclNob3c6IGhpZGVPclNob3csXG4gICAgYWRkVVJMUXVlcnlQYXJhbWV0ZXI6IGFkZFVSTFF1ZXJ5UGFyYW1ldGVyLFxuICAgIHJlbW92ZUR1cGxpY2F0ZU9iamVjdHM6IHJlbW92ZUR1cGxpY2F0ZU9iamVjdHMsXG4gICAgbWVyZ2VTdGFjazogbWVyZ2VTdGFjayxcbiAgICBpc0VsZW1lbnRJblZpZXdwb3J0OiBpc0VsZW1lbnRJblZpZXdwb3J0LFxuICAgIGhhc1ZhbHVlOiBoYXNWYWx1ZSxcbiAgICBwYXJzZVRpbWU6IHBhcnNlVGltZSxcbiAgICBmaW5kUmVsYXRpdmVzOiBmaW5kUmVsYXRpdmVzLFxuICAgIGdldF9ib3VuZHM6IGdldF9ib3VuZHMsXG4gICAgY2hlY2tJbnB1dFN1cHBvcnQ6IGNoZWNrSW5wdXRTdXBwb3J0LFxuICAgIGNoZWNrQ1NTRmVhdHVyZTogY2hlY2tDU1NGZWF0dXJlLFxuICAgIGFuaW1hdGlvbl9mcmFtZTogYW5pbWF0aW9uX2ZyYW1lLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgZGVib3VuY2U6IGRlYm91bmNlLFxuICAgIGlzSUU6IGlzSUUsXG4gICAganFUb05vZGU6IGpxVG9Ob2RlLFxuICAgIGVuc3VyZUFycmF5OiBlbnN1cmVBcnJheSxcbiAgICBsb2NhbGl6ZWRfaXNvZGF0ZTogbG9jYWxpemVkX2lzb2RhdGUsXG4gICAgZXNjYXBlX2h0bWw6IGVzY2FwZV9odG1sLFxuICAgIHVuZXNjYXBlX2h0bWw6IHVuZXNjYXBlX2h0bWwsXG4gICAgaXNfaXNvX2RhdGVfdGltZTogaXNfaXNvX2RhdGVfdGltZSxcbiAgICBnZXRDU1NWYWx1ZTogZG9tLmdldF9jc3NfdmFsdWUsIC8vIEJCQjogbW92ZWQgdG8gZG9tLiBUT0RPOiBSZW1vdmUgaW4gdXBjb21pbmcgdmVyc2lvbi5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWxzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBydW50aW1lIGhlbHBlciBmb3Igc2V0dGluZyBwcm9wZXJ0aWVzIG9uIGNvbXBvbmVudHNcbi8vIGluIGEgdHJlZS1zaGFrYWJsZSB3YXlcbmV4cG9ydHMuZGVmYXVsdCA9IChzZmMsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2ZjLl9fdmNjT3B0cyB8fCBzZmM7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHByb3BzKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==