"use strict";
(self["webpackChunksimplelayout"] = self["webpackChunksimplelayout"] || []).push([["vendors-node_modules_patternslib_patternslib_src_core_registry_js-node_modules_vue-loader_dis-fc4403"],{

/***/ "./node_modules/@patternslib/patternslib/src/core/dom.js":
/*!***************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/dom.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ "./node_modules/@patternslib/patternslib/src/core/events.js");
/* Utilities for DOM traversal or navigation */


const DATA_PREFIX = "__patternslib__data_prefix__";
const DATA_STYLE_DISPLAY = "__patternslib__style__display";

const toNodeArray = (nodes) => {
    // Return an array of DOM nodes
    if (nodes.jquery || nodes instanceof NodeList) {
        // jQuery or document.querySelectorAll
        nodes = [...nodes];
    } else if (nodes instanceof Array === false) {
        nodes = [nodes];
    }
    return nodes;
};

const querySelectorAllAndMe = (el, selector) => {
    // Like querySelectorAll but including the element where it starts from.
    // Returns an Array, not a NodeList

    if (!el) {
        return [];
    }

    const all = [...el.querySelectorAll(selector)];
    if (el.matches(selector)) {
        all.unshift(el); // start element should be first.
    }
    return all;
};

const wrap = (el, wrapper) => {
    // Wrap a element with a wrapper element.
    // See: https://stackoverflow.com/a/13169465/1337474

    el.parentNode.insertBefore(wrapper, el);
    wrapper.appendChild(el);
};

const hide = (el) => {
    // Hides the element with ``display: none``
    if (el.style.display === "none") {
        // Nothing to do.
        return;
    }
    if (el.style.display) {
        el[DATA_STYLE_DISPLAY] = el.style.display;
    }
    el.style.display = "none";
    el.setAttribute("hidden", "");
};

const show = (el) => {
    // Shows element by removing ``display: none`` and restoring the display
    // value to whatever it was before.
    const val = el[DATA_STYLE_DISPLAY] || null;
    el.style.display = val;
    delete el[DATA_STYLE_DISPLAY];
    el.removeAttribute("hidden", "");
};

const find_parents = (el, selector) => {
    // Return all direct parents of ``el`` matching ``selector``.
    // This matches against all parents but not the element itself.
    // The order of elements is from the search starting point up to higher
    // DOM levels.
    const ret = [];
    let parent = el?.parentNode?.closest?.(selector);
    while (parent) {
        ret.push(parent);
        parent = parent.parentNode?.closest?.(selector);
    }
    return ret;
};

const find_scoped = (el, selector) => {
    // If the selector starts with an object id do a global search,
    // otherwise do a local search.
    return (selector.indexOf("#") === 0 ? document : el).querySelectorAll(selector);
};

const get_parents = (el) => {
    // Return all HTMLElement parents of el, starting from the direct parent of el.
    // The document itself is excluded because it's not a real DOM node.
    const parents = [];
    let parent = el?.parentNode;
    while (parent) {
        parents.push(parent);
        parent = parent?.parentNode;
        parent = parent instanceof HTMLElement ? parent : null;
    }
    return parents;
};

/**
 * Return the value of the first attribute found in the list of parents.
 *
 * @param {DOM element} el - The DOM element to start the acquisition search for the given attribute.
 * @param {string} attribute - Name of the attribute to search for.
 * @param {Boolean} include_empty - Also return empty values.
 * @param {Boolean} include_all - Return a list of attribute values found in all parents.
 *
 * @returns {*} - Returns the value of the searched attribute or a list of all attributes.
 */
const acquire_attribute = (
    el,
    attribute,
    include_empty = false,
    include_all = false
) => {
    let _el = el;
    const ret = []; // array for ``include_all`` mode.
    while (_el) {
        const val = _el.getAttribute(attribute);
        if (val || (include_empty && val === "")) {
            if (!include_all) {
                return val;
            }
            ret.push(val);
        }
        _el = _el.parentElement;
    }
    if (include_all) {
        return ret;
    }
};

const is_visible = (el) => {
    // Check, if element is visible in DOM.
    // https://stackoverflow.com/a/19808107/1337474
    return el.offsetWidth > 0 && el.offsetHeight > 0;
};

/**
 * Return a DocumentFragment from a given string.
 *
 * @param {String} string - The HTML structure as a string.
 *
 * @returns {DocumentFragment} - The DOM nodes as a DocumentFragment.
 */
const create_from_string = (string) => {
    // See: https://davidwalsh.name/convert-html-stings-dom-nodes
    return document.createRange().createContextualFragment(string.trim());
};

/**
 * Return a CSS property value for a given DOM node.
 * For length-values, relative values are converted to pixels.
 * Optionally parse as pixels, if applicable.
 *
 * Note: The element must be attached to the body to make CSS caluclations work.
 *
 * @param {Node} el - DOM node.
 * @param {String} property - CSS property to query on DOM node.
 * @param {Boolean} [as_pixels=false] - Convert value to pixels, if applicable.
 * @param {Boolean} [as_float=false] - Convert value to float, if applicable.
 *
 * @returns {(String|Number)} - The CSS value to return.
 */
function get_css_value(el, property, as_pixels = false, as_float = false) {
    let value = window.getComputedStyle(el).getPropertyValue(property);
    if (as_pixels || as_float) {
        value = parseFloat(value) || 0.0;
    }
    if (as_pixels && !as_float) {
        value = parseInt(Math.round(value), 10);
    }
    return value;
}

/**
 * Find a scrollable element up in the DOM tree.
 *
 * Note: Setting the ``overflow`` shorthand property also sets the individual overflow-y and overflow-y properties.
 *
 * @param {Node} el - The DOM element to start the search on.
 * @param {String} [direction=] - Not given: Search for any scrollable element up in the DOM tree.
 *                                ``x``: Search for a horizontally scrollable element.
 *                                ``y``: Search for a vertically scrollable element.
 * @param {(DOM Node|null)} [fallback=document.body] - Fallback, if no scroll container can be found.
 *                                                     The default is to use document.body.
 *
 * @returns {Node} - Return the first scrollable element.
 *                   If no other element could be found, document.body would be returned.
 */
const find_scroll_container = (el, direction, fallback = document.body) => {
    while (el && el !== document.body) {
        if (!direction || direction === "y") {
            let overflow_y = get_css_value(el, "overflow-y");
            if (["auto", "scroll"].includes(overflow_y)) {
                return el;
            }
        }
        if (!direction || direction === "x") {
            let overflow_x = get_css_value(el, "overflow-x");
            if (["auto", "scroll"].includes(overflow_x)) {
                return el;
            }
        }
        el = el.parentElement;
    }
    return fallback;
};

/**
 * Get data stored directly on the node instance.
 * We are using a prefix to make sure the data doesn't collide with other attributes.
 *
 * @param el {Node} - The DOM node from which we want to retrieve the data.
 * @param name {String} - The name of the variable. Note - this is stored on
 *                        the DOM node prefixed with the DATA_PREFIX.
 * @param default_value {Any} - Optional default value.
 * @return {Any} - The value which is stored on the DOM node.
 */
const get_data = (el, name, default_value) => {
    return el[`${DATA_PREFIX}${name}`] || default_value;
};

/**
 * Set and store data directly on the node instance.
 * We are using a prefix to make sure the data doesn't collide with other attributes.
 *
 * @param el {Node} - The DOM node which we want to store the data on.
 * @param name {String} - The name of the variable. Note - this is stored on
 *                        the DOM node prefixed with the DATA_PREFIX.
 * @param value {Any} - The value we want to store on the DOM node.
 */
const set_data = (el, name, value) => {
    el[`${DATA_PREFIX}${name}`] = value;
};

/**
 * Simple template engine, based on JS template literal
 *
 * Please note: You cannot pass a template literal as template_string.
 * JavaScript itself would try to expand it and would fail.
 *
 * See: https://stackoverflow.com/a/37217166/1337474
 *
 * @param {String} template_string - The template string as a JavaScript template literal.
 *                                   For each variable in the template you have to use ``this``.
 *                                   E.g. if you pass ``{message: "ok"}`` as template_variables, you can use it like so:
 *                                   `<h1>${this.message}</h1>`
 * @param {Object} template_variables - Object literal with all the variables which should be used in the template.
 *
 * @returns {String} - Returns the a string as template expanded with the template_variables.
 */
const template = (template_string, template_variables = {}) => {
    return new Function("return `" + template_string + "`;").call(template_variables);
};

const dom = {
    toNodeArray: toNodeArray,
    querySelectorAllAndMe: querySelectorAllAndMe,
    wrap: wrap,
    hide: hide,
    show: show,
    find_parents: find_parents,
    find_scoped: find_scoped,
    get_parents: get_parents,
    acquire_attribute: acquire_attribute,
    is_visible: is_visible,
    create_from_string: create_from_string,
    get_css_value: get_css_value,
    find_scroll_container: find_scroll_container,
    get_data: get_data,
    set_data: set_data,
    template: template,
    add_event_listener: _events__WEBPACK_IMPORTED_MODULE_0__["default"].add_event_listener, // BBB export. TODO: Remove in an upcoming version.
    remove_event_listener: _events__WEBPACK_IMPORTED_MODULE_0__["default"].remove_event_listener, // BBB export. TODO: Remove in an upcoming version.
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dom);


/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/events.js":
/*!******************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/events.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Event related methods and event factories

// Event listener registration for easy-to-remove event listeners.
// once Safari supports the ``signal`` option for addEventListener we can abort
// event handlers by calling AbortController.abort().
const event_listener_map = {};

/**
 * Add an event listener to a DOM element under a unique id.
 * If a event is registered under the same id for the same element, the old handler is removed first.
 *
 * @param {DOM Node} el - The element to register the event for.
 * @param {string} event_type - The event type to listen for.
 * @param {string} id - A unique id under which the event is registered.
 * @param {function} cb - The event handler / callback function.
 * @param {Object} opts - Options for the addEventListener API.
 *
 */
const add_event_listener = (el, event_type, id, cb, opts = {}) => {
    if (!el?.addEventListener) {
        return; // nothing to do.
    }
    remove_event_listener(el, id); // do not register one listener twice.

    if (!event_listener_map[el]) {
        event_listener_map[el] = {};
    }
    event_listener_map[el][id] = [event_type, cb, opts.capture ? opts : undefined]; // prettier-ignore
    el.addEventListener(event_type, cb, opts);
};

/**
 * Remove an event listener from a DOM element under a unique id.
 *
 * @param {DOM Node} el - The element to register the event for.
 * @param {string} id - A unique id under which the event is registered.
 *
 */
const remove_event_listener = (el, id) => {
    if (!el?.removeEventListener) {
        return; // nothing to do.
    }
    const el_events = event_listener_map[el];
    if (!el_events) {
        return;
    }
    let entries;
    if (id) {
        // remove event listener with specific id
        const entry = el_events[id];
        entries = entry ? [entry] : [];
    } else {
        // remove all event listeners of element
        entries = Object.entries(el_events);
    }
    for (const entry of entries || []) {
        el.removeEventListener(entry[0], entry[1], entry[2]);
    }
};

/**
 * Await an event to be thrown.
 *
 * Usage:
 *     await events.await_event(button, "click");
 *
 * @param {DOM Node} el - The element to listen on.
 * @param {String} event_name - The event name to listen for.
 *
 * @returns {Promise} - Returns a Promise which can be used for ``await`` and which will be resolved when the event is throwm.
 *
 */
const await_event = (el, event_name) => {
    // See: https://stackoverflow.com/a/44746691/1337474
    return new Promise((resolve) =>
        el.addEventListener(event_name, resolve, { once: true })
    );
};

/**
 * Await pattern init.
 *
 * Usage:
 *     await events.await_pattern_init(PATTERN);
 *
 * @param {Pattern instance} pattern - The pattern instance.
 *
 * @returns {Promise} - Returns a Promise which can be used for ``await`` and which will be resolved when the event is throwm.
 *
 */
const await_pattern_init = (pattern) => {
    // See: https://stackoverflow.com/a/44746691/1337474
    return new Promise((resolve) => pattern.one("init", resolve));
};

/**
 * Event factories
 */

const click_event = () => {
    return new Event("click", {
        bubbles: true,
        cancelable: true,
    });
};

const change_event = () => {
    return new Event("change", {
        bubbles: true,
        cancelable: false,
    });
};

const input_event = () => {
    return new Event("input", {
        bubbles: true,
        cancelable: false,
    });
};

const mousedown_event = () => {
    return new Event("mousedown", {
        bubbles: true,
        cancelable: true,
    });
};

const mouseup_event = () => {
    return new Event("mouseup", {
        bubbles: true,
        cancelable: true,
    });
};

const scroll_event = () => {
    return new Event("scroll", {
        bubbles: true,
        cancelable: false,
    });
};

const submit_event = () => {
    return new Event("submit", {
        bubbles: true,
        cancelable: true,
    });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    add_event_listener: add_event_listener,
    remove_event_listener: remove_event_listener,
    await_event: await_event,
    await_pattern_init: await_pattern_init,
    click_event: click_event,
    change_event: change_event,
    input_event: input_event,
    mousedown_event: mousedown_event,
    mouseup_event: mouseup_event,
    scroll_event: scroll_event,
    submit_event: submit_event,
});


/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/logging.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/logging.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Patterns logging - minimal logging framework
 *
 * Copyright 2012 Simplon B.V.
 */

// source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== "function") {
            // closest thing possible to the ECMAScript 5 internal IsCallable function
            throw new TypeError(
                "Function.prototype.bind - what is trying to be bound is not callable"
            );
        }

        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function () {},
            fBound = function () {
                return fToBind.apply(
                    this instanceof fNOP && oThis ? this : oThis,
                    aArgs.concat(Array.prototype.slice.call(arguments))
                );
            };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();

        return fBound;
    };
}

var root, // root logger instance
    writer; // writer instance, used to output log entries

var Level = {
    DEBUG: 10,
    INFO: 20,
    WARN: 30,
    ERROR: 40,
    FATAL: 50,
};

function ConsoleWriter() {}

ConsoleWriter.prototype = {
    output: function (log_name, level, messages) {
        if (log_name) messages.unshift(log_name + ":");
        if (level <= Level.DEBUG) {
            // console.debug exists but is deprecated
            messages.unshift("[DEBUG]");
            console.log.apply(console, messages);
        } else if (level <= Level.INFO) console.info.apply(console, messages);
        else if (level <= Level.WARN) console.warn.apply(console, messages);
        else console.error.apply(console, messages);
    },
};

function Logger(name, parent) {
    this._loggers = {};
    this.name = name || "";
    this._parent = parent || null;
    if (!parent) {
        this._enabled = true;
        this._level = Level.WARN;
    }
}

Logger.prototype = {
    getLogger: function (name) {
        var path = name.split("."),
            root = this,
            route = this.name ? [this.name] : [];
        while (path.length) {
            var entry = path.shift();
            route.push(entry);
            if (!(entry in root._loggers))
                root._loggers[entry] = new Logger(route.join("."), root);
            root = root._loggers[entry];
        }
        return root;
    },

    _getFlag: function (flag) {
        var context = this;
        flag = "_" + flag;
        while (context !== null) {
            if (context[flag] !== undefined) return context[flag];
            context = context._parent;
        }
        return null;
    },

    setEnabled: function (state) {
        this._enabled = !!state;
    },

    isEnabled: function () {
        this._getFlag("enabled");
    },

    setLevel: function (level) {
        if (typeof level === "number") this._level = level;
        else if (typeof level === "string") {
            level = level.toUpperCase();
            if (level in Level) this._level = Level[level];
        }
    },

    getLevel: function () {
        return this._getFlag("level");
    },

    log: function (level, messages) {
        if (
            !messages.length ||
            !this._getFlag("enabled") ||
            level < this._getFlag("level")
        )
            return;
        messages = Array.prototype.slice.call(messages);
        writer.output(this.name, level, messages);
    },

    debug: function () {
        this.log(Level.DEBUG, arguments);
    },

    info: function () {
        this.log(Level.INFO, arguments);
    },

    warn: function () {
        this.log(Level.WARN, arguments);
    },

    error: function () {
        this.log(Level.ERROR, arguments);
    },

    fatal: function () {
        this.log(Level.FATAL, arguments);
    },
};

function getWriter() {
    return writer;
}

function setWriter(w) {
    writer = w;
}

setWriter(new ConsoleWriter());

root = new Logger();

var logconfig = /loglevel(|-[^=]+)=([^&]+)/g,
    match;

while ((match = logconfig.exec(window.location.search)) !== null) {
    var logger = match[1] === "" ? root : root.getLogger(match[1].slice(1));
    logger.setLevel(match[2].toUpperCase());
}

var api = {
    Level: Level,
    getLogger: root.getLogger.bind(root),
    setEnabled: root.setEnabled.bind(root),
    isEnabled: root.isEnabled.bind(root),
    setLevel: root.setLevel.bind(root),
    getLevel: root.getLevel.bind(root),
    debug: root.debug.bind(root),
    info: root.info.bind(root),
    warn: root.warn.bind(root),
    error: root.error.bind(root),
    fatal: root.fatal.bind(root),
    getWriter: getWriter,
    setWriter: setWriter,
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (api);


/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/registry.js":
/*!********************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/registry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PATTERN_REGISTRY": () => (/* binding */ PATTERN_REGISTRY),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "webpack/sharing/consume/default/jquery/jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom */ "./node_modules/@patternslib/patternslib/src/core/dom.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging */ "./node_modules/@patternslib/patternslib/src/core/logging.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./node_modules/@patternslib/patternslib/src/core/utils.js");
/**
 * Patterns registry - Central registry and scan logic for patterns
 *
 * Copyright 2012-2013 Simplon B.V.
 * Copyright 2012-2013 Florian Friesdorf
 * Copyright 2013 Marko Durkovic
 * Copyright 2013 Rok Garbas
 * Copyright 2014-2015 Syslab.com GmBH, JC Brand
 */

/*
 * changes to previous patterns.register/scan mechanism
 * - if you want initialised class, do it in init
 * - init returns set of elements actually initialised
 * - handle once within init
 * - no turnstile anymore
 * - set pattern.jquery_plugin if you want it
 */





const log = _logging__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("registry");
const disable_re = /patterns-disable=([^&]+)/g;
const dont_catch_re = /patterns-dont-catch/g;
const disabled = {};
let dont_catch = false;
let match;

while ((match = disable_re.exec(window.location.search)) !== null) {
    disabled[match[1]] = true;
    log.info("Pattern disabled via url config:", match[1]);
}

while ((match = dont_catch_re.exec(window.location.search)) !== null) {
    dont_catch = true;
    log.info("I will not catch init exceptions");
}

/**
 * Global pattern registry.
 *
 * This is a singleton and shared among any instance of the Patternslib
 * registry since Patternslib version 8.
 *
 * You normally don't need this as the registry handles it for you.
 */
if (typeof window.__patternslib_registry === "undefined") {
    window.__patternslib_registry = {};
}
const PATTERN_REGISTRY = window.__patternslib_registry;
if (typeof window.__patternslib_registry_initialized === "undefined") {
    window.__patternslib_registry_initialized = false;
}

const registry = {
    patterns: PATTERN_REGISTRY, // reference to global patterns registry
    // as long as the registry is not initialized, pattern
    // registration just registers a pattern. Once init is called,
    // the DOM is scanned. After that registering a new pattern
    // results in rescanning the DOM only for this pattern.
    init() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
            if (window.__patternslib_registry_initialized) {
                // Do not reinitialize a already initialized registry.
                return;
            }
            window.__patternslib_registry_initialized = true;
            log.debug("Loaded: " + Object.keys(registry.patterns).sort().join(", "));
            registry.scan(document.body);
            log.debug("Finished initial scan.");
        });
    },

    clear() {
        // Removes all patterns from the registry. Currently only being
        // used in tests.
        for (const name in registry.patterns) {
            delete registry.patterns[name];
        }
    },

    transformPattern(name, content) {
        /* Call the transform method on the pattern with the given name, if
         * it exists.
         */
        if (disabled[name]) {
            log.debug(`Skipping disabled pattern: ${name}.`);
            return;
        }

        const pattern = registry.patterns[name];
        const transform = pattern.transform || pattern.prototype?.transform;
        if (transform) {
            try {
                transform(jquery__WEBPACK_IMPORTED_MODULE_0___default()(content));
            } catch (e) {
                if (dont_catch) {
                    throw e;
                }
                log.error(`Transform error for pattern ${name}.`, e);
            }
        }
    },

    initPattern(name, el, trigger) {
        /* Initialize the pattern with the provided name and in the context
         * of the passed in DOM element.
         */
        const $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el);
        const pattern = registry.patterns[name];
        if (pattern.init) {
            const plog = _logging__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger(`pat.${name}`);
            if ($el.is(pattern.trigger)) {
                plog.debug("Initialising.", $el);
                try {
                    pattern.init($el, null, trigger);
                    plog.debug("done.");
                } catch (e) {
                    if (dont_catch) {
                        throw e;
                    }
                    plog.error("Caught error:", e);
                }
            }
        }
    },

    orderPatterns(patterns) {
        // XXX: Bit of a hack. We need the validation pattern to be
        // parsed and initiated before the inject pattern. So we make
        // sure here, that it appears first. Not sure what would be
        // the best solution. Perhaps some kind of way to register
        // patterns "before" or "after" other patterns.
        if (patterns.includes("validation") && patterns.includes("inject")) {
            patterns.splice(patterns.indexOf("validation"), 1);
            patterns.unshift("validation");
        }
        return patterns;
    },

    scan(content, patterns, trigger) {
        if (!content) {
            return;
        }

        if (typeof content === "string") {
            content = document.querySelector(content);
        } else if (content.jquery) {
            content = content[0];
        }

        const selectors = [];
        patterns = this.orderPatterns(patterns || Object.keys(registry.patterns));
        for (const name of patterns) {
            this.transformPattern(name, content);
            const pattern = registry.patterns[name];
            if (pattern.trigger) {
                selectors.unshift(pattern.trigger);
            }
        }

        let matches = _dom__WEBPACK_IMPORTED_MODULE_1__["default"].querySelectorAllAndMe(
            content,
            selectors.map((it) => it.trim().replace(/,$/, "")).join(",")
        );
        matches = matches.filter((el) => {
            // Filter out patterns:
            // - with class ``.disable-patterns``
            // - wrapped in ``.disable-patterns`` elements
            // - wrapped in ``<pre>`` elements
            // - wrapped in ``<template>`` elements
            return (
                !el.matches(".disable-patterns") &&
                !el?.parentNode?.closest?.(".disable-patterns") &&
                !el?.parentNode?.closest?.("pre") &&
                !el?.parentNode?.closest?.("template") && // NOTE: not strictly necessary. Template is a DocumentFragment and not reachable except for IE.
                !el.matches(".cant-touch-this") && // BBB. TODO: Remove with next major version.
                !el?.parentNode?.closest?.(".cant-touch-this") // BBB. TODO: Remove with next major version.
            );
        });

        // walk list backwards and initialize patterns inside-out.
        for (const el of matches.reverse()) {
            for (const name of patterns) {
                this.initPattern(name, el, trigger);
            }
        }
        document.body.classList.add("patterns-loaded");
    },

    register(pattern, name) {
        name = name || pattern.name;
        if (!name) {
            log.error("Pattern lacks a name.", pattern);
            return false;
        }
        if (registry.patterns[name]) {
            log.debug(`Already have a pattern called ${name}.`);
            return false;
        }
        // register pattern to be used for scanning new content
        registry.patterns[name] = pattern;

        // register pattern as jquery plugin
        if (pattern.jquery_plugin) {
            const plugin_name = ("pat-" + name).replace(
                /-([a-zA-Z])/g,
                function (match, p1) {
                    return p1.toUpperCase();
                }
            );
            (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[plugin_name] = _utils__WEBPACK_IMPORTED_MODULE_3__["default"].jqueryPlugin(pattern);
            // BBB 2012-12-10 and also for Mockup patterns.
            (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[plugin_name.replace(/^pat/, "pattern")] = (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[plugin_name];
        }
        log.debug(`Registered pattern ${name}`, pattern);
        if (window.__patternslib_registry_initialized) {
            // Once the first initialization has been done, do only scan for
            // newly registered patterns.
            registry.scan(document.body, [name]);
            log.debug(`Re-scanned dom with newly registered pattern ${name}.`);
        }
        return true;
    },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registry);


/***/ }),

/***/ "./node_modules/@patternslib/patternslib/src/core/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@patternslib/patternslib/src/core/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "webpack/sharing/consume/default/jquery/jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom */ "./node_modules/@patternslib/patternslib/src/core/dom.js");



(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn.safeClone) = function () {
    var $clone = this.clone();
    // IE BUG : Placeholder text becomes actual value after deep clone on textarea
    // https://connect.microsoft.com/IE/feedback/details/781612/placeholder-text-becomes-actual-value-after-deep-clone-on-textarea
    if (window.document.documentMode) {
        $clone.findInclusive(":input[placeholder]").each(function (i, item) {
            var $item = jquery__WEBPACK_IMPORTED_MODULE_0___default()(item);
            if ($item.attr("placeholder") === $item.val()) {
                $item.val("");
            }
        });
    }
    return $clone;
};

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this === null) {
            throw new TypeError(" this is null or not defined");
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== "function") {
            throw new TypeError(callback + " is not a function");
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        // 7. Repeat, while k < len
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}

var singleBoundJQueryPlugin = function (pattern, method, options) {
    /* This is a jQuery plugin for patterns which are invoked ONCE FOR EACH
     * matched element in the DOM.
     *
     * This is how the Mockup-type patterns behave. They are constructor
     * functions which need to be invoked once per jQuery-wrapped DOM node
     * for all DOM nodes on which the pattern applies.
     */
    var $this = this;
    $this.each(function () {
        var pat,
            $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
        pat = pattern.init($el, options);
        if (method) {
            if (pat[method] === undefined) {
                jquery__WEBPACK_IMPORTED_MODULE_0___default().error(
                    "Method " + method + " does not exist on jQuery." + pattern.name
                );
                return false;
            }
            if (method.charAt(0) === "_") {
                jquery__WEBPACK_IMPORTED_MODULE_0___default().error("Method " + method + " is private on jQuery." + pattern.name);
                return false;
            }
            pat[method].apply(pat, [options]);
        }
    });
    return $this;
};

var pluralBoundJQueryPlugin = function (pattern, method, options) {
    /* This is a jQuery plugin for patterns which are invoked ONCE FOR ALL
     * matched elements in the DOM.
     *
     * This is how the vanilla Patternslib-type patterns behave. They are
     * simple objects with an init method and this method gets called once
     * with a list of jQuery-wrapped DOM nodes on which the pattern
     * applies.
     */
    var $this = this;
    if (method) {
        if (pattern[method]) {
            return pattern[method].apply($this, [$this].concat([options]));
        } else {
            jquery__WEBPACK_IMPORTED_MODULE_0___default().error("Method " + method + " does not exist on jQuery." + pattern.name);
        }
    } else {
        pattern.init.apply($this, [$this].concat([options]));
    }
    return $this;
};

var jqueryPlugin = function (pattern) {
    return function (method, options) {
        var $this = this;
        if ($this.length === 0) {
            return $this;
        }
        if (typeof method === "object") {
            options = method;
            method = undefined;
        }
        if (typeof pattern === "function") {
            return singleBoundJQueryPlugin.call(this, pattern, method, options);
        } else {
            return pluralBoundJQueryPlugin.call(this, pattern, method, options);
        }
    };
};

// Is a given variable an object?
function isObject(obj) {
    var type = typeof obj;
    return type === "function" || (type === "object" && !!obj);
}

// Extend a given object with all the properties in passed-in object(s).
function extend(obj) {
    if (!isObject(obj)) return obj;
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        for (prop in source) {
            if (hasOwnProperty.call(source, prop)) {
                obj[prop] = source[prop];
            }
        }
    }
    return obj;
}
// END: Taken from Underscore.js until here.

function rebaseURL(base, url) {
    base = new URL(base, window.location).href; // If base is relative make it absolute.
    if (url.indexOf("://") !== -1 || url[0] === "/" || url.indexOf("data:") === 0) {
        return url;
    }
    return base.slice(0, base.lastIndexOf("/") + 1) + url;
}

function findLabel(input) {
    var $label;
    for (
        var label = input.parentNode;
        label && label.nodeType !== 11;
        label = label.parentNode
    ) {
        if (label.tagName === "LABEL") {
            return label;
        }
    }
    if (input.id) {
        $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()('label[for="' + input.id + '"]');
    }
    if ($label && $label.length === 0 && input.form) {
        $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()('label[for="' + input.name + '"]', input.form);
    }
    if ($label && $label.length) {
        return $label[0];
    } else {
        return null;
    }
}

// Taken from http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport
function elementInViewport(el) {
    var rect = el.getBoundingClientRect(),
        docEl = document.documentElement,
        vWidth = window.innerWidth || docEl.clientWidth,
        vHeight = window.innerHeight || docEl.clientHeight;

    if (rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight)
        return false;
    return true;
}

// Taken from http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

/**
 * Remove classes from a list of targets if they match a specific pattern.
 *
 * @param {Node, NodeList} targets: Dom Node or NodeList where the classes should be removed.
 * @param {string} classes: String matching classes to be removed.
 *                          You can add a "*" as wildcard to search for classes to be removed.
 *                          E.g. "icon-*-alert" to remove any of "icon-1-alert icon-2-alert".
 *
 * @returns {undefined}: This method directly operates on the targets.
 */
function removeWildcardClass(targets, classes) {
    targets = utils.ensureArray(targets);

    if (classes.indexOf("*") === -1) {
        for (const target of targets) {
            target.classList.remove(classes);
        }
    } else {
        let matcher = classes.replace(/[\-\[\]{}()+?.,\\\^$|#\s]/g, "\\$&");
        matcher = matcher.replace(/[*]/g, ".*");
        matcher = new RegExp("^" + matcher + "$");

        for (const target of targets) {
            const class_list = (target.getAttribute("class") || "").split(/\s+/);
            if (!class_list.length) {
                continue;
            }
            const ok = class_list.filter((it) => !matcher.test(it));
            if (ok.length) {
                target.setAttribute("class", ok.join(" "));
            } else {
                target.removeAttribute("class");
            }
        }
    }
}

function hasValue(el) {
    if (el.tagName === "INPUT") {
        if (el.type === "checkbox" || el.type === "radio") {
            return el.checked;
        }
        return el.value !== "";
    }
    if (el.tagName === "SELECT") {
        return el.selectedIndex !== -1;
    }
    if (el.tagName === "TEXTAREA") {
        return el.value !== "";
    }
    return false;
}

const hideOrShow = (nodes, visible, options, pattern_name) => {
    nodes = _dom__WEBPACK_IMPORTED_MODULE_1__["default"].toNodeArray(nodes);

    const transitions = {
        none: { hide: "hide", show: "show" },
        fade: { hide: "fadeOut", show: "fadeIn" },
        slide: { hide: "slideUp", show: "slideDown" },
    };

    const duration =
        options.transition === "css" || options.transition === "none"
            ? null
            : options.effect.duration;

    const on_complete = (el) => {
        el.classList.remove("in-progress");
        el.classList.add(visible ? "visible" : "hidden");
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).trigger("pat-update", {
            pattern: pattern_name,
            transition: "complete",
        });
    };

    for (const el of nodes) {
        el.classList.remove("visible");
        el.classList.remove("hidden");
        el.classList.remove("in-progress");

        if (duration) {
            const t = transitions[options.transition];
            el.classList.add("in-progress");
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).trigger("pat-update", {
                pattern: pattern_name,
                transition: "start",
            });
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(el)[visible ? t.show : t.hide]({
                duration: duration,
                easing: options.effect.easing,
                complete: () => on_complete(el),
            });
        } else {
            if (options.transition !== "css") {
                _dom__WEBPACK_IMPORTED_MODULE_1__["default"][visible ? "show" : "hide"](el);
            }
            on_complete(el);
        }
    }
};

function addURLQueryParameter(fullURL, param, value) {
    /* Using a positive lookahead (?=\=) to find the given parameter,
     * preceded by a ? or &, and followed by a = with a value after
     * than (using a non-greedy selector) and then followed by
     * a & or the end of the string.
     *
     * Taken from http://stackoverflow.com/questions/7640270/adding-modify-query-string-get-variables-in-a-url-with-javascript
     */
    var val = new RegExp("(\\?|\\&)" + param + "=.*?(?=(&|$))"),
        parts = fullURL.toString().split("#"),
        url = parts[0],
        hash = parts[1],
        qstring = /\?.+$/,
        newURL = url;
    // Check if the parameter exists
    if (val.test(url)) {
        // if it does, replace it, using the captured group
        // to determine & or ? at the beginning
        newURL = url.replace(val, "$1" + param + "=" + value);
    } else if (qstring.test(url)) {
        // otherwise, if there is a query string at all
        // add the param to the end of it
        newURL = url + "&" + param + "=" + value;
    } else {
        // if there's no query string, add one
        newURL = url + "?" + param + "=" + value;
    }
    if (hash) {
        newURL += "#" + hash;
    }
    return newURL;
}

function removeDuplicateObjects(objs) {
    /* Given an array of objects, remove any duplicate objects which might
     * be present.
     */
    const comparator = function (k, v) {
        return this[k] === v;
    };

    return objs.reduce(function (list, next_obj) {
        let is_duplicate = false;
        for (const obj of list) {
            is_duplicate =
                Object.keys(obj).length === Object.keys(next_obj).length &&
                Object.entries(obj).filter(
                    (it) => !comparator.bind(next_obj)(it[0], it[1])
                ).length === 0;
        }
        if (!is_duplicate) {
            list.push(next_obj);
        }
        return list;
    }, []);
}

function mergeStack(stack, length) {
    /* Given a list of lists of objects (which for brevity we call a stack),
     * return a list of objects where each object is the merge of all the
     * corresponding original objects at that particular index.
     *
     * If a certain sub-list doesn't have an object at that particular
     * index, the last object in that list is merged.
     */
    const results = [];
    for (let i = 0; i < length; i++) {
        results.push({});
    }
    for (const frame of stack) {
        const frame_length = frame.length - 1;
        for (let x = 0; x < length; x++) {
            results[x] = jquery__WEBPACK_IMPORTED_MODULE_0___default().extend(
                results[x] || {},
                frame[x > frame_length ? frame_length : x]
            );
        }
    }
    return results;
}

function isElementInViewport(el, partial = false, offset = 0) {
    /* returns true if element is visible to the user ie. is in the viewport.
     * Setting partial parameter to true, will only check if a part of the element is visible
     * in the viewport, specifically that some part of that element is touching the top part
     * of the viewport. This only applies to the vertical direction, ie. doesnt check partial
     * visibility for horizontal scrolling
     * some code taken from:
     * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/7557433#7557433
     */
    if (el instanceof (jquery__WEBPACK_IMPORTED_MODULE_0___default())) {
        el = el[0];
    }

    const rec = el.getBoundingClientRect();
    const rec_values = [rec.top, rec.bottom, rec.left, rec.right];

    if (rec_values.every((val) => val === 0)) {
        // if every property of rec is 0, the element is invisible;
        return false;
    } else if (partial) {
        // when using getBoundingClientRect() (in the vertical case)
        // negative means above top of viewport, positive means below top of viewport
        // therefore for part of the element to be touching or crossing the top of the viewport
        // rec.top must <= 0 and rec.bottom must >= 0
        // an optional tolerance offset can be added for when the desired element is not exactly
        // toucing the top of the viewport but needs to be considered as touching.
        return (
            rec.top <= 0 + offset && rec.bottom >= 0 + offset
            //(rec.top >= 0+offset && rec.top <= window.innerHeight) // this checks if the element
            // touches bottom part of viewport
            // XXX do we want to include a check for the padding of an element?
            // using window.getComputedStyle(target).paddingTop
        );
    } else {
        // this will return true if the entire element is completely in the viewport
        return (
            rec.top >= 0 &&
            rec.left >= 0 &&
            rec.bottom <=
                (window.innerHeight || document.documentElement.clientHeight) &&
            rec.right <= (window.innerWidth || document.documentElement.clientWidth)
        );
    }
}

function parseTime(time) {
    var m = /^(\d+(?:\.\d+)?)\s*(\w*)/.exec(time);
    if (!m) {
        throw new Error("Invalid time");
    }
    var amount = parseFloat(m[1]);
    switch (m[2]) {
        case "s":
            return Math.round(amount * 1000);
        case "m":
            return Math.round(amount * 1000 * 60);
        case "ms":
        default:
            return Math.round(amount);
    }
}

// Return a jQuery object with elements related to an input element.
function findRelatives(el) {
    var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el),
        $relatives = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el),
        $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()();

    $relatives = $relatives.add($el.closest("label"));
    $relatives = $relatives.add($el.closest("fieldset"));

    if (el.id) $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()("label[for='" + el.id + "']");
    if (!$label.length) {
        var $form = $el.closest("form");
        if (!$form.length) $form = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body);
        $label = $form.find("label[for='" + el.name + "']");
    }
    $relatives = $relatives.add($label);
    return $relatives;
}

function get_bounds(el) {
    // Return bounds of an element with it's values rounded and converted to ints.
    const bounds = el.getBoundingClientRect();
    return {
        x: parseInt(Math.round(bounds.x), 10) || 0,
        y: parseInt(Math.round(bounds.y), 10) || 0,
        top: parseInt(Math.round(bounds.top), 10) || 0,
        bottom: parseInt(Math.round(bounds.bottom), 10) || 0,
        left: parseInt(Math.round(bounds.left), 10) || 0,
        right: parseInt(Math.round(bounds.right), 10) || 0,
        width: parseInt(Math.round(bounds.width), 10) || 0,
        height: parseInt(Math.round(bounds.height), 10) || 0,
    };
}

function checkInputSupport(type, invalid_value) {
    /* Check input type support.
     *  See: https://stackoverflow.com/a/10199306/1337474
     */
    let support = false;
    const input = document.createElement("input");
    input.setAttribute("type", type);
    support = input.type == type;

    if (invalid_value !== undefined) {
        // Check for input type UI support
        input.setAttribute("value", invalid_value);
        support = input.value !== invalid_value;
    }
    return support;
}

const checkCSSFeature = (attribute, value, tag = "div") => {
    /* Check for browser support of specific CSS feature.
     */
    tag = document.createElement(tag);
    let supported = tag.style[attribute] !== undefined;
    if (supported && value !== undefined) {
        tag.style[attribute] = value;
        supported = tag.style[attribute] === value;
    }
    return supported;
};

const animation_frame = () => {
    // Return promise to await next repaint cycle
    // Use it in your async function like so: ``await utils.animation_frame()``
    // From: http://www.albertlobo.com/fractals/async-await-requestanimationframe-buddhabrot
    return new Promise(window.requestAnimationFrame);
};

const timeout = (ms) => {
    return new Promise((resolve) => setTimeout(resolve, ms));
};

const debounce = (func, ms, timer = { timer: null }) => {
    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds.
    // From: https://underscorejs.org/#debounce
    //
    // Make sure to initialize ``debounce`` only once per to-be-debounced
    // function to not reinitialize the timer each time and debounce not being
    // able to cancel previouse runs.
    //
    // Pass a module-global timer as an object ``{ timer: null }`` if you want
    // to also cancel debounced functions from other pattern-invocations.
    //
    return function () {
        clearTimeout(timer.timer);
        const args = arguments;
        timer.timer = setTimeout(() => func.apply(this, args), ms);
    };
};

const isIE = () => {
    // See: https://stackoverflow.com/a/9851769/1337474
    // Internet Explorer 6-11
    return /*@cc_on!@*/  false || !!document.documentMode;
};

const jqToNode = (el) => {
    // Return a DOM node if a jQuery node was passed.
    if (el.jquery) {
        el = el[0];
    }
    return el;
};

/**
 * Always return an iterable object.
 *
 * @param {any} it: The object which needs to be wrapped in an array or returned as is if it is iterable.
 * @param {boolean} force_array: If the object is iterable but not an Array, convert it to an array (e.g. For jQuery items or NodeList objects).
 *
 * @returns {Array}: Returns the object wrapped in an Array, expanded to an Array or as-is if it is already iterable.
 */
const ensureArray = (it, force_array) => {
    // Ensure to return always an array
    const array_like = !!(
        NodeList.prototype.isPrototypeOf(it) || // eslint-disable-line no-prototype-builtins
        Array.isArray(it) ||
        it.jquery
    );
    return array_like ? (force_array ? [...it] : it) : [it];
};

const localized_isodate = (date) => {
    // Return a iso date (date only) in the current timezone instead of a
    // UTC ISO 8601 date+time component which toISOString returns.

    const day = date.getDate().toString().padStart(2, "0");
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const year = date.getFullYear().toString();

    return `${year}-${month}-${day}`;
};

/**
 * Replace HTML reserved characters with html entities to add HTML for user
 * editing to e.g. a textarea or a contenteditable.
 *
 * See: https://developer.mozilla.org/en-US/docs/Glossary/Entity#reserved_characters
 *
 * @param {string} html - The HTML string to encode.
 *
 * @returns {string} - Returns the escaped html string:
 *                     ``&`` will be replaced with ``&amp;``.
 *                     ``<`` will be repalced with ``&lt;``,
 *                     ``>`` will be replaced with ``&gt;``,
 *                     ``"`` will be replaced with ``&quot;``.
 */
const escape_html = (html) => {
    return (html || "")
        .replace(/&/g, "&amp;") // needs to be first!
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;");
};

/**
 * Return unescaped, raw HTML from an escaped HTML  string.
 *
 * See: https://developer.mozilla.org/en-US/docs/Glossary/Entity#reserved_characters
 *
 * @param {string} escaped_html - The HTML string to decode.
 *
 * @returns {string} - Returns the escaped html string:
 *                     ``&amp;`` will be replaced with ``&``,
 *                     ``&lt;`` will be repalced with ``<``,
 *                     ``&gt;`` will be replaced with ``>``,
 *                     ``&quot;`` will be replaced with ``"``.
 */
const unescape_html = (escaped_html) => {
    return (escaped_html || "")
        .replace(/&amp;/g, "&")
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&quot;/g, '"');
};

/**
 * Return true, if the given value is a valid ISO 8601 date/time string with or without an optional time component.
 *
 * @param {String} value - The date/time value to be checked.
 * @param {Boolean} [optional_time=false] - True, if time component is optional.
 * @return {Boolean} - True, if the given value is a valid Date string. False if not.
 */
const is_iso_date_time = (value, optional_time = false) => {
    const re_date_time = optional_time
        ? /^\d{4}-[01]\d-[0-3]\d(T[0-2]\d:[0-5]\d)?$/
        : /^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d$/;
    return re_date_time.test(value);
};

var utils = {
    // pattern pimping - own module?
    jqueryPlugin: jqueryPlugin,
    escapeRegExp: escapeRegExp,
    isObject: isObject,
    extend: extend,
    rebaseURL: rebaseURL,
    findLabel: findLabel,
    elementInViewport: elementInViewport,
    removeWildcardClass: removeWildcardClass,
    hideOrShow: hideOrShow,
    addURLQueryParameter: addURLQueryParameter,
    removeDuplicateObjects: removeDuplicateObjects,
    mergeStack: mergeStack,
    isElementInViewport: isElementInViewport,
    hasValue: hasValue,
    parseTime: parseTime,
    findRelatives: findRelatives,
    get_bounds: get_bounds,
    checkInputSupport: checkInputSupport,
    checkCSSFeature: checkCSSFeature,
    animation_frame: animation_frame,
    timeout: timeout,
    debounce: debounce,
    isIE: isIE,
    jqToNode: jqToNode,
    ensureArray: ensureArray,
    localized_isodate: localized_isodate,
    escape_html: escape_html,
    unescape_html: unescape_html,
    is_iso_date_time: is_iso_date_time,
    getCSSValue: _dom__WEBPACK_IMPORTED_MODULE_1__["default"].get_css_value, // BBB: moved to dom. TODO: Remove in upcoming version.
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utils);


/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3BhdHRlcm5zbGliX3BhdHRlcm5zbGliX3NyY19jb3JlX3JlZ2lzdHJ5X2pzLW5vZGVfbW9kdWxlc192dWUtbG9hZGVyX2Rpcy1mYzQ0MDMuM2E1MTk4Nzg2OWQ1NzFjMGRhMjMubWluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSx5QkFBeUIsS0FBSztBQUM5QixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixZQUFZLEVBQUUsS0FBSztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQSxVQUFVLFlBQVksRUFBRSxLQUFLO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSx5REFBeUQsY0FBYztBQUN2RSw0Q0FBNEMsYUFBYTtBQUN6RCxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQXlCO0FBQ2pELDJCQUEyQixxRUFBNEI7QUFDdkQ7O0FBRUEsaUVBQWUsR0FBRyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUNqUm5COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7OztBQ2hLRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVM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QVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwREFBaUI7QUFDbEM7O0FBRUEsaUVBQWUsS0FBSyxFQUFDOzs7Ozs7Ozs7OztBQ3RxQlI7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlbGF5b3V0Ly4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuc2xpYi9wYXR0ZXJuc2xpYi9zcmMvY29yZS9kb20uanMiLCJ3ZWJwYWNrOi8vc2ltcGxlbGF5b3V0Ly4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuc2xpYi9wYXR0ZXJuc2xpYi9zcmMvY29yZS9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vc2ltcGxlbGF5b3V0Ly4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuc2xpYi9wYXR0ZXJuc2xpYi9zcmMvY29yZS9sb2dnaW5nLmpzIiwid2VicGFjazovL3NpbXBsZWxheW91dC8uL25vZGVfbW9kdWxlcy9AcGF0dGVybnNsaWIvcGF0dGVybnNsaWIvc3JjL2NvcmUvcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vc2ltcGxlbGF5b3V0Ly4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuc2xpYi9wYXR0ZXJuc2xpYi9zcmMvY29yZS91dGlscy5qcyIsIndlYnBhY2s6Ly9zaW1wbGVsYXlvdXQvLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBVdGlsaXRpZXMgZm9yIERPTSB0cmF2ZXJzYWwgb3IgbmF2aWdhdGlvbiAqL1xuaW1wb3J0IGV2ZW50cyBmcm9tIFwiLi9ldmVudHNcIjtcblxuY29uc3QgREFUQV9QUkVGSVggPSBcIl9fcGF0dGVybnNsaWJfX2RhdGFfcHJlZml4X19cIjtcbmNvbnN0IERBVEFfU1RZTEVfRElTUExBWSA9IFwiX19wYXR0ZXJuc2xpYl9fc3R5bGVfX2Rpc3BsYXlcIjtcblxuY29uc3QgdG9Ob2RlQXJyYXkgPSAobm9kZXMpID0+IHtcbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gICAgaWYgKG5vZGVzLmpxdWVyeSB8fCBub2RlcyBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG4gICAgICAgIC8vIGpRdWVyeSBvciBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsXG4gICAgICAgIG5vZGVzID0gWy4uLm5vZGVzXTtcbiAgICB9IGVsc2UgaWYgKG5vZGVzIGluc3RhbmNlb2YgQXJyYXkgPT09IGZhbHNlKSB7XG4gICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufTtcblxuY29uc3QgcXVlcnlTZWxlY3RvckFsbEFuZE1lID0gKGVsLCBzZWxlY3RvcikgPT4ge1xuICAgIC8vIExpa2UgcXVlcnlTZWxlY3RvckFsbCBidXQgaW5jbHVkaW5nIHRoZSBlbGVtZW50IHdoZXJlIGl0IHN0YXJ0cyBmcm9tLlxuICAgIC8vIFJldHVybnMgYW4gQXJyYXksIG5vdCBhIE5vZGVMaXN0XG5cbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhbGwgPSBbLi4uZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildO1xuICAgIGlmIChlbC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICBhbGwudW5zaGlmdChlbCk7IC8vIHN0YXJ0IGVsZW1lbnQgc2hvdWxkIGJlIGZpcnN0LlxuICAgIH1cbiAgICByZXR1cm4gYWxsO1xufTtcblxuY29uc3Qgd3JhcCA9IChlbCwgd3JhcHBlcikgPT4ge1xuICAgIC8vIFdyYXAgYSBlbGVtZW50IHdpdGggYSB3cmFwcGVyIGVsZW1lbnQuXG4gICAgLy8gU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTMxNjk0NjUvMTMzNzQ3NFxuXG4gICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlciwgZWwpO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWwpO1xufTtcblxuY29uc3QgaGlkZSA9IChlbCkgPT4ge1xuICAgIC8vIEhpZGVzIHRoZSBlbGVtZW50IHdpdGggYGBkaXNwbGF5OiBub25lYGBcbiAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBkby5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSkge1xuICAgICAgICBlbFtEQVRBX1NUWUxFX0RJU1BMQVldID0gZWwuc3R5bGUuZGlzcGxheTtcbiAgICB9XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGVsLnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcIlwiKTtcbn07XG5cbmNvbnN0IHNob3cgPSAoZWwpID0+IHtcbiAgICAvLyBTaG93cyBlbGVtZW50IGJ5IHJlbW92aW5nIGBgZGlzcGxheTogbm9uZWBgIGFuZCByZXN0b3JpbmcgdGhlIGRpc3BsYXlcbiAgICAvLyB2YWx1ZSB0byB3aGF0ZXZlciBpdCB3YXMgYmVmb3JlLlxuICAgIGNvbnN0IHZhbCA9IGVsW0RBVEFfU1RZTEVfRElTUExBWV0gfHwgbnVsbDtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsO1xuICAgIGRlbGV0ZSBlbFtEQVRBX1NUWUxFX0RJU1BMQVldO1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcImhpZGRlblwiLCBcIlwiKTtcbn07XG5cbmNvbnN0IGZpbmRfcGFyZW50cyA9IChlbCwgc2VsZWN0b3IpID0+IHtcbiAgICAvLyBSZXR1cm4gYWxsIGRpcmVjdCBwYXJlbnRzIG9mIGBgZWxgYCBtYXRjaGluZyBgYHNlbGVjdG9yYGAuXG4gICAgLy8gVGhpcyBtYXRjaGVzIGFnYWluc3QgYWxsIHBhcmVudHMgYnV0IG5vdCB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgLy8gVGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIGZyb20gdGhlIHNlYXJjaCBzdGFydGluZyBwb2ludCB1cCB0byBoaWdoZXJcbiAgICAvLyBET00gbGV2ZWxzLlxuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGxldCBwYXJlbnQgPSBlbD8ucGFyZW50Tm9kZT8uY2xvc2VzdD8uKHNlbGVjdG9yKTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIHJldC5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlPy5jbG9zZXN0Py4oc2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuY29uc3QgZmluZF9zY29wZWQgPSAoZWwsIHNlbGVjdG9yKSA9PiB7XG4gICAgLy8gSWYgdGhlIHNlbGVjdG9yIHN0YXJ0cyB3aXRoIGFuIG9iamVjdCBpZCBkbyBhIGdsb2JhbCBzZWFyY2gsXG4gICAgLy8gb3RoZXJ3aXNlIGRvIGEgbG9jYWwgc2VhcmNoLlxuICAgIHJldHVybiAoc2VsZWN0b3IuaW5kZXhPZihcIiNcIikgPT09IDAgPyBkb2N1bWVudCA6IGVsKS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbn07XG5cbmNvbnN0IGdldF9wYXJlbnRzID0gKGVsKSA9PiB7XG4gICAgLy8gUmV0dXJuIGFsbCBIVE1MRWxlbWVudCBwYXJlbnRzIG9mIGVsLCBzdGFydGluZyBmcm9tIHRoZSBkaXJlY3QgcGFyZW50IG9mIGVsLlxuICAgIC8vIFRoZSBkb2N1bWVudCBpdHNlbGYgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCdzIG5vdCBhIHJlYWwgRE9NIG5vZGUuXG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIGxldCBwYXJlbnQgPSBlbD8ucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQ/LnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gcGFyZW50IDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGF0dHJpYnV0ZSBmb3VuZCBpbiB0aGUgbGlzdCBvZiBwYXJlbnRzLlxuICpcbiAqIEBwYXJhbSB7RE9NIGVsZW1lbnR9IGVsIC0gVGhlIERPTSBlbGVtZW50IHRvIHN0YXJ0IHRoZSBhY3F1aXNpdGlvbiBzZWFyY2ggZm9yIHRoZSBnaXZlbiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVfZW1wdHkgLSBBbHNvIHJldHVybiBlbXB0eSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVfYWxsIC0gUmV0dXJuIGEgbGlzdCBvZiBhdHRyaWJ1dGUgdmFsdWVzIGZvdW5kIGluIGFsbCBwYXJlbnRzLlxuICpcbiAqIEByZXR1cm5zIHsqfSAtIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzZWFyY2hlZCBhdHRyaWJ1dGUgb3IgYSBsaXN0IG9mIGFsbCBhdHRyaWJ1dGVzLlxuICovXG5jb25zdCBhY3F1aXJlX2F0dHJpYnV0ZSA9IChcbiAgICBlbCxcbiAgICBhdHRyaWJ1dGUsXG4gICAgaW5jbHVkZV9lbXB0eSA9IGZhbHNlLFxuICAgIGluY2x1ZGVfYWxsID0gZmFsc2VcbikgPT4ge1xuICAgIGxldCBfZWwgPSBlbDtcbiAgICBjb25zdCByZXQgPSBbXTsgLy8gYXJyYXkgZm9yIGBgaW5jbHVkZV9hbGxgYCBtb2RlLlxuICAgIHdoaWxlIChfZWwpIHtcbiAgICAgICAgY29uc3QgdmFsID0gX2VsLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICBpZiAodmFsIHx8IChpbmNsdWRlX2VtcHR5ICYmIHZhbCA9PT0gXCJcIikpIHtcbiAgICAgICAgICAgIGlmICghaW5jbHVkZV9hbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgICBfZWwgPSBfZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGVfYWxsKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufTtcblxuY29uc3QgaXNfdmlzaWJsZSA9IChlbCkgPT4ge1xuICAgIC8vIENoZWNrLCBpZiBlbGVtZW50IGlzIHZpc2libGUgaW4gRE9NLlxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTgwODEwNy8xMzM3NDc0XG4gICAgcmV0dXJuIGVsLm9mZnNldFdpZHRoID4gMCAmJiBlbC5vZmZzZXRIZWlnaHQgPiAwO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBEb2N1bWVudEZyYWdtZW50IGZyb20gYSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIFRoZSBIVE1MIHN0cnVjdHVyZSBhcyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7RG9jdW1lbnRGcmFnbWVudH0gLSBUaGUgRE9NIG5vZGVzIGFzIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAqL1xuY29uc3QgY3JlYXRlX2Zyb21fc3RyaW5nID0gKHN0cmluZykgPT4ge1xuICAgIC8vIFNlZTogaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvY29udmVydC1odG1sLXN0aW5ncy1kb20tbm9kZXNcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoc3RyaW5nLnRyaW0oKSk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIENTUyBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBET00gbm9kZS5cbiAqIEZvciBsZW5ndGgtdmFsdWVzLCByZWxhdGl2ZSB2YWx1ZXMgYXJlIGNvbnZlcnRlZCB0byBwaXhlbHMuXG4gKiBPcHRpb25hbGx5IHBhcnNlIGFzIHBpeGVscywgaWYgYXBwbGljYWJsZS5cbiAqXG4gKiBOb3RlOiBUaGUgZWxlbWVudCBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBib2R5IHRvIG1ha2UgQ1NTIGNhbHVjbGF0aW9ucyB3b3JrLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZWwgLSBET00gbm9kZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIENTUyBwcm9wZXJ0eSB0byBxdWVyeSBvbiBET00gbm9kZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzX3BpeGVscz1mYWxzZV0gLSBDb252ZXJ0IHZhbHVlIHRvIHBpeGVscywgaWYgYXBwbGljYWJsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzX2Zsb2F0PWZhbHNlXSAtIENvbnZlcnQgdmFsdWUgdG8gZmxvYXQsIGlmIGFwcGxpY2FibGUuXG4gKlxuICogQHJldHVybnMgeyhTdHJpbmd8TnVtYmVyKX0gLSBUaGUgQ1NTIHZhbHVlIHRvIHJldHVybi5cbiAqL1xuZnVuY3Rpb24gZ2V0X2Nzc192YWx1ZShlbCwgcHJvcGVydHksIGFzX3BpeGVscyA9IGZhbHNlLCBhc19mbG9hdCA9IGZhbHNlKSB7XG4gICAgbGV0IHZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgIGlmIChhc19waXhlbHMgfHwgYXNfZmxvYXQpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwLjA7XG4gICAgfVxuICAgIGlmIChhc19waXhlbHMgJiYgIWFzX2Zsb2F0KSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJbnQoTWF0aC5yb3VuZCh2YWx1ZSksIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEZpbmQgYSBzY3JvbGxhYmxlIGVsZW1lbnQgdXAgaW4gdGhlIERPTSB0cmVlLlxuICpcbiAqIE5vdGU6IFNldHRpbmcgdGhlIGBgb3ZlcmZsb3dgYCBzaG9ydGhhbmQgcHJvcGVydHkgYWxzbyBzZXRzIHRoZSBpbmRpdmlkdWFsIG92ZXJmbG93LXkgYW5kIG92ZXJmbG93LXkgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IGVsIC0gVGhlIERPTSBlbGVtZW50IHRvIHN0YXJ0IHRoZSBzZWFyY2ggb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RpcmVjdGlvbj1dIC0gTm90IGdpdmVuOiBTZWFyY2ggZm9yIGFueSBzY3JvbGxhYmxlIGVsZW1lbnQgdXAgaW4gdGhlIERPTSB0cmVlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBgeGBgOiBTZWFyY2ggZm9yIGEgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUgZWxlbWVudC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYHlgYDogU2VhcmNoIGZvciBhIHZlcnRpY2FsbHkgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICogQHBhcmFtIHsoRE9NIE5vZGV8bnVsbCl9IFtmYWxsYmFjaz1kb2N1bWVudC5ib2R5XSAtIEZhbGxiYWNrLCBpZiBubyBzY3JvbGwgY29udGFpbmVyIGNhbiBiZSBmb3VuZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCBpcyB0byB1c2UgZG9jdW1lbnQuYm9keS5cbiAqXG4gKiBAcmV0dXJucyB7Tm9kZX0gLSBSZXR1cm4gdGhlIGZpcnN0IHNjcm9sbGFibGUgZWxlbWVudC5cbiAqICAgICAgICAgICAgICAgICAgIElmIG5vIG90aGVyIGVsZW1lbnQgY291bGQgYmUgZm91bmQsIGRvY3VtZW50LmJvZHkgd291bGQgYmUgcmV0dXJuZWQuXG4gKi9cbmNvbnN0IGZpbmRfc2Nyb2xsX2NvbnRhaW5lciA9IChlbCwgZGlyZWN0aW9uLCBmYWxsYmFjayA9IGRvY3VtZW50LmJvZHkpID0+IHtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgaWYgKCFkaXJlY3Rpb24gfHwgZGlyZWN0aW9uID09PSBcInlcIikge1xuICAgICAgICAgICAgbGV0IG92ZXJmbG93X3kgPSBnZXRfY3NzX3ZhbHVlKGVsLCBcIm92ZXJmbG93LXlcIik7XG4gICAgICAgICAgICBpZiAoW1wiYXV0b1wiLCBcInNjcm9sbFwiXS5pbmNsdWRlcyhvdmVyZmxvd195KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpcmVjdGlvbiB8fCBkaXJlY3Rpb24gPT09IFwieFwiKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmZsb3dfeCA9IGdldF9jc3NfdmFsdWUoZWwsIFwib3ZlcmZsb3cteFwiKTtcbiAgICAgICAgICAgIGlmIChbXCJhdXRvXCIsIFwic2Nyb2xsXCJdLmluY2x1ZGVzKG92ZXJmbG93X3gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xufTtcblxuLyoqXG4gKiBHZXQgZGF0YSBzdG9yZWQgZGlyZWN0bHkgb24gdGhlIG5vZGUgaW5zdGFuY2UuXG4gKiBXZSBhcmUgdXNpbmcgYSBwcmVmaXggdG8gbWFrZSBzdXJlIHRoZSBkYXRhIGRvZXNuJ3QgY29sbGlkZSB3aXRoIG90aGVyIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIGVsIHtOb2RlfSAtIFRoZSBET00gbm9kZSBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIGRhdGEuXG4gKiBAcGFyYW0gbmFtZSB7U3RyaW5nfSAtIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZS4gTm90ZSAtIHRoaXMgaXMgc3RvcmVkIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBET00gbm9kZSBwcmVmaXhlZCB3aXRoIHRoZSBEQVRBX1BSRUZJWC5cbiAqIEBwYXJhbSBkZWZhdWx0X3ZhbHVlIHtBbnl9IC0gT3B0aW9uYWwgZGVmYXVsdCB2YWx1ZS5cbiAqIEByZXR1cm4ge0FueX0gLSBUaGUgdmFsdWUgd2hpY2ggaXMgc3RvcmVkIG9uIHRoZSBET00gbm9kZS5cbiAqL1xuY29uc3QgZ2V0X2RhdGEgPSAoZWwsIG5hbWUsIGRlZmF1bHRfdmFsdWUpID0+IHtcbiAgICByZXR1cm4gZWxbYCR7REFUQV9QUkVGSVh9JHtuYW1lfWBdIHx8IGRlZmF1bHRfdmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCBhbmQgc3RvcmUgZGF0YSBkaXJlY3RseSBvbiB0aGUgbm9kZSBpbnN0YW5jZS5cbiAqIFdlIGFyZSB1c2luZyBhIHByZWZpeCB0byBtYWtlIHN1cmUgdGhlIGRhdGEgZG9lc24ndCBjb2xsaWRlIHdpdGggb3RoZXIgYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0gZWwge05vZGV9IC0gVGhlIERPTSBub2RlIHdoaWNoIHdlIHdhbnQgdG8gc3RvcmUgdGhlIGRhdGEgb24uXG4gKiBAcGFyYW0gbmFtZSB7U3RyaW5nfSAtIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZS4gTm90ZSAtIHRoaXMgaXMgc3RvcmVkIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBET00gbm9kZSBwcmVmaXhlZCB3aXRoIHRoZSBEQVRBX1BSRUZJWC5cbiAqIEBwYXJhbSB2YWx1ZSB7QW55fSAtIFRoZSB2YWx1ZSB3ZSB3YW50IHRvIHN0b3JlIG9uIHRoZSBET00gbm9kZS5cbiAqL1xuY29uc3Qgc2V0X2RhdGEgPSAoZWwsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgZWxbYCR7REFUQV9QUkVGSVh9JHtuYW1lfWBdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNpbXBsZSB0ZW1wbGF0ZSBlbmdpbmUsIGJhc2VkIG9uIEpTIHRlbXBsYXRlIGxpdGVyYWxcbiAqXG4gKiBQbGVhc2Ugbm90ZTogWW91IGNhbm5vdCBwYXNzIGEgdGVtcGxhdGUgbGl0ZXJhbCBhcyB0ZW1wbGF0ZV9zdHJpbmcuXG4gKiBKYXZhU2NyaXB0IGl0c2VsZiB3b3VsZCB0cnkgdG8gZXhwYW5kIGl0IGFuZCB3b3VsZCBmYWlsLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3MjE3MTY2LzEzMzc0NzRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVfc3RyaW5nIC0gVGhlIHRlbXBsYXRlIHN0cmluZyBhcyBhIEphdmFTY3JpcHQgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZWFjaCB2YXJpYWJsZSBpbiB0aGUgdGVtcGxhdGUgeW91IGhhdmUgdG8gdXNlIGBgdGhpc2BgLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUuZy4gaWYgeW91IHBhc3MgYGB7bWVzc2FnZTogXCJva1wifWBgIGFzIHRlbXBsYXRlX3ZhcmlhYmxlcywgeW91IGNhbiB1c2UgaXQgbGlrZSBzbzpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPGgxPiR7dGhpcy5tZXNzYWdlfTwvaDE+YFxuICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlX3ZhcmlhYmxlcyAtIE9iamVjdCBsaXRlcmFsIHdpdGggYWxsIHRoZSB2YXJpYWJsZXMgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IC0gUmV0dXJucyB0aGUgYSBzdHJpbmcgYXMgdGVtcGxhdGUgZXhwYW5kZWQgd2l0aCB0aGUgdGVtcGxhdGVfdmFyaWFibGVzLlxuICovXG5jb25zdCB0ZW1wbGF0ZSA9ICh0ZW1wbGF0ZV9zdHJpbmcsIHRlbXBsYXRlX3ZhcmlhYmxlcyA9IHt9KSA9PiB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInJldHVybiBgXCIgKyB0ZW1wbGF0ZV9zdHJpbmcgKyBcImA7XCIpLmNhbGwodGVtcGxhdGVfdmFyaWFibGVzKTtcbn07XG5cbmNvbnN0IGRvbSA9IHtcbiAgICB0b05vZGVBcnJheTogdG9Ob2RlQXJyYXksXG4gICAgcXVlcnlTZWxlY3RvckFsbEFuZE1lOiBxdWVyeVNlbGVjdG9yQWxsQW5kTWUsXG4gICAgd3JhcDogd3JhcCxcbiAgICBoaWRlOiBoaWRlLFxuICAgIHNob3c6IHNob3csXG4gICAgZmluZF9wYXJlbnRzOiBmaW5kX3BhcmVudHMsXG4gICAgZmluZF9zY29wZWQ6IGZpbmRfc2NvcGVkLFxuICAgIGdldF9wYXJlbnRzOiBnZXRfcGFyZW50cyxcbiAgICBhY3F1aXJlX2F0dHJpYnV0ZTogYWNxdWlyZV9hdHRyaWJ1dGUsXG4gICAgaXNfdmlzaWJsZTogaXNfdmlzaWJsZSxcbiAgICBjcmVhdGVfZnJvbV9zdHJpbmc6IGNyZWF0ZV9mcm9tX3N0cmluZyxcbiAgICBnZXRfY3NzX3ZhbHVlOiBnZXRfY3NzX3ZhbHVlLFxuICAgIGZpbmRfc2Nyb2xsX2NvbnRhaW5lcjogZmluZF9zY3JvbGxfY29udGFpbmVyLFxuICAgIGdldF9kYXRhOiBnZXRfZGF0YSxcbiAgICBzZXRfZGF0YTogc2V0X2RhdGEsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIGFkZF9ldmVudF9saXN0ZW5lcjogZXZlbnRzLmFkZF9ldmVudF9saXN0ZW5lciwgLy8gQkJCIGV4cG9ydC4gVE9ETzogUmVtb3ZlIGluIGFuIHVwY29taW5nIHZlcnNpb24uXG4gICAgcmVtb3ZlX2V2ZW50X2xpc3RlbmVyOiBldmVudHMucmVtb3ZlX2V2ZW50X2xpc3RlbmVyLCAvLyBCQkIgZXhwb3J0LiBUT0RPOiBSZW1vdmUgaW4gYW4gdXBjb21pbmcgdmVyc2lvbi5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRvbTtcbiIsIi8vIEV2ZW50IHJlbGF0ZWQgbWV0aG9kcyBhbmQgZXZlbnQgZmFjdG9yaWVzXG5cbi8vIEV2ZW50IGxpc3RlbmVyIHJlZ2lzdHJhdGlvbiBmb3IgZWFzeS10by1yZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxuLy8gb25jZSBTYWZhcmkgc3VwcG9ydHMgdGhlIGBgc2lnbmFsYGAgb3B0aW9uIGZvciBhZGRFdmVudExpc3RlbmVyIHdlIGNhbiBhYm9ydFxuLy8gZXZlbnQgaGFuZGxlcnMgYnkgY2FsbGluZyBBYm9ydENvbnRyb2xsZXIuYWJvcnQoKS5cbmNvbnN0IGV2ZW50X2xpc3RlbmVyX21hcCA9IHt9O1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBhIERPTSBlbGVtZW50IHVuZGVyIGEgdW5pcXVlIGlkLlxuICogSWYgYSBldmVudCBpcyByZWdpc3RlcmVkIHVuZGVyIHRoZSBzYW1lIGlkIGZvciB0aGUgc2FtZSBlbGVtZW50LCB0aGUgb2xkIGhhbmRsZXIgaXMgcmVtb3ZlZCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0RPTSBOb2RlfSBlbCAtIFRoZSBlbGVtZW50IHRvIHJlZ2lzdGVyIHRoZSBldmVudCBmb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfdHlwZSAtIFRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBBIHVuaXF1ZSBpZCB1bmRlciB3aGljaCB0aGUgZXZlbnQgaXMgcmVnaXN0ZXJlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIC0gVGhlIGV2ZW50IGhhbmRsZXIgLyBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyBmb3IgdGhlIGFkZEV2ZW50TGlzdGVuZXIgQVBJLlxuICpcbiAqL1xuY29uc3QgYWRkX2V2ZW50X2xpc3RlbmVyID0gKGVsLCBldmVudF90eXBlLCBpZCwgY2IsIG9wdHMgPSB7fSkgPT4ge1xuICAgIGlmICghZWw/LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBub3RoaW5nIHRvIGRvLlxuICAgIH1cbiAgICByZW1vdmVfZXZlbnRfbGlzdGVuZXIoZWwsIGlkKTsgLy8gZG8gbm90IHJlZ2lzdGVyIG9uZSBsaXN0ZW5lciB0d2ljZS5cblxuICAgIGlmICghZXZlbnRfbGlzdGVuZXJfbWFwW2VsXSkge1xuICAgICAgICBldmVudF9saXN0ZW5lcl9tYXBbZWxdID0ge307XG4gICAgfVxuICAgIGV2ZW50X2xpc3RlbmVyX21hcFtlbF1baWRdID0gW2V2ZW50X3R5cGUsIGNiLCBvcHRzLmNhcHR1cmUgPyBvcHRzIDogdW5kZWZpbmVkXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudF90eXBlLCBjYiwgb3B0cyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGEgRE9NIGVsZW1lbnQgdW5kZXIgYSB1bmlxdWUgaWQuXG4gKlxuICogQHBhcmFtIHtET00gTm9kZX0gZWwgLSBUaGUgZWxlbWVudCB0byByZWdpc3RlciB0aGUgZXZlbnQgZm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gQSB1bmlxdWUgaWQgdW5kZXIgd2hpY2ggdGhlIGV2ZW50IGlzIHJlZ2lzdGVyZWQuXG4gKlxuICovXG5jb25zdCByZW1vdmVfZXZlbnRfbGlzdGVuZXIgPSAoZWwsIGlkKSA9PiB7XG4gICAgaWYgKCFlbD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm47IC8vIG5vdGhpbmcgdG8gZG8uXG4gICAgfVxuICAgIGNvbnN0IGVsX2V2ZW50cyA9IGV2ZW50X2xpc3RlbmVyX21hcFtlbF07XG4gICAgaWYgKCFlbF9ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZW50cmllcztcbiAgICBpZiAoaWQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIHdpdGggc3BlY2lmaWMgaWRcbiAgICAgICAgY29uc3QgZW50cnkgPSBlbF9ldmVudHNbaWRdO1xuICAgICAgICBlbnRyaWVzID0gZW50cnkgPyBbZW50cnldIDogW107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgb2YgZWxlbWVudFxuICAgICAgICBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZWxfZXZlbnRzKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzIHx8IFtdKSB7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW50cnlbMF0sIGVudHJ5WzFdLCBlbnRyeVsyXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBd2FpdCBhbiBldmVudCB0byBiZSB0aHJvd24uXG4gKlxuICogVXNhZ2U6XG4gKiAgICAgYXdhaXQgZXZlbnRzLmF3YWl0X2V2ZW50KGJ1dHRvbiwgXCJjbGlja1wiKTtcbiAqXG4gKiBAcGFyYW0ge0RPTSBOb2RlfSBlbCAtIFRoZSBlbGVtZW50IHRvIGxpc3RlbiBvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIC0gVGhlIGV2ZW50IG5hbWUgdG8gbGlzdGVuIGZvci5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBSZXR1cm5zIGEgUHJvbWlzZSB3aGljaCBjYW4gYmUgdXNlZCBmb3IgYGBhd2FpdGBgIGFuZCB3aGljaCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIGV2ZW50IGlzIHRocm93bS5cbiAqXG4gKi9cbmNvbnN0IGF3YWl0X2V2ZW50ID0gKGVsLCBldmVudF9uYW1lKSA9PiB7XG4gICAgLy8gU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDQ3NDY2OTEvMTMzNzQ3NFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCByZXNvbHZlLCB7IG9uY2U6IHRydWUgfSlcbiAgICApO1xufTtcblxuLyoqXG4gKiBBd2FpdCBwYXR0ZXJuIGluaXQuXG4gKlxuICogVXNhZ2U6XG4gKiAgICAgYXdhaXQgZXZlbnRzLmF3YWl0X3BhdHRlcm5faW5pdChQQVRURVJOKTtcbiAqXG4gKiBAcGFyYW0ge1BhdHRlcm4gaW5zdGFuY2V9IHBhdHRlcm4gLSBUaGUgcGF0dGVybiBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBSZXR1cm5zIGEgUHJvbWlzZSB3aGljaCBjYW4gYmUgdXNlZCBmb3IgYGBhd2FpdGBgIGFuZCB3aGljaCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIGV2ZW50IGlzIHRocm93bS5cbiAqXG4gKi9cbmNvbnN0IGF3YWl0X3BhdHRlcm5faW5pdCA9IChwYXR0ZXJuKSA9PiB7XG4gICAgLy8gU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDQ3NDY2OTEvMTMzNzQ3NFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcGF0dGVybi5vbmUoXCJpbml0XCIsIHJlc29sdmUpKTtcbn07XG5cbi8qKlxuICogRXZlbnQgZmFjdG9yaWVzXG4gKi9cblxuY29uc3QgY2xpY2tfZXZlbnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBFdmVudChcImNsaWNrXCIsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IGNoYW5nZV9ldmVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IEV2ZW50KFwiY2hhbmdlXCIsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgfSk7XG59O1xuXG5jb25zdCBpbnB1dF9ldmVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IEV2ZW50KFwiaW5wdXRcIiwge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IG1vdXNlZG93bl9ldmVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IEV2ZW50KFwibW91c2Vkb3duXCIsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IG1vdXNldXBfZXZlbnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBFdmVudChcIm1vdXNldXBcIiwge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIH0pO1xufTtcblxuY29uc3Qgc2Nyb2xsX2V2ZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgRXZlbnQoXCJzY3JvbGxcIiwge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IHN1Ym1pdF9ldmVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IEV2ZW50KFwic3VibWl0XCIsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBhZGRfZXZlbnRfbGlzdGVuZXI6IGFkZF9ldmVudF9saXN0ZW5lcixcbiAgICByZW1vdmVfZXZlbnRfbGlzdGVuZXI6IHJlbW92ZV9ldmVudF9saXN0ZW5lcixcbiAgICBhd2FpdF9ldmVudDogYXdhaXRfZXZlbnQsXG4gICAgYXdhaXRfcGF0dGVybl9pbml0OiBhd2FpdF9wYXR0ZXJuX2luaXQsXG4gICAgY2xpY2tfZXZlbnQ6IGNsaWNrX2V2ZW50LFxuICAgIGNoYW5nZV9ldmVudDogY2hhbmdlX2V2ZW50LFxuICAgIGlucHV0X2V2ZW50OiBpbnB1dF9ldmVudCxcbiAgICBtb3VzZWRvd25fZXZlbnQ6IG1vdXNlZG93bl9ldmVudCxcbiAgICBtb3VzZXVwX2V2ZW50OiBtb3VzZXVwX2V2ZW50LFxuICAgIHNjcm9sbF9ldmVudDogc2Nyb2xsX2V2ZW50LFxuICAgIHN1Ym1pdF9ldmVudDogc3VibWl0X2V2ZW50LFxufTtcbiIsIi8qKlxuICogUGF0dGVybnMgbG9nZ2luZyAtIG1pbmltYWwgbG9nZ2luZyBmcmFtZXdvcmtcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiBTaW1wbG9uIEIuVi5cbiAqL1xuXG4vLyBzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZFxuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgICAgICBmTk9QID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICBmQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID8gdGhpcyA6IG9UaGlzLFxuICAgICAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICB9O1xufVxuXG52YXIgcm9vdCwgLy8gcm9vdCBsb2dnZXIgaW5zdGFuY2VcbiAgICB3cml0ZXI7IC8vIHdyaXRlciBpbnN0YW5jZSwgdXNlZCB0byBvdXRwdXQgbG9nIGVudHJpZXNcblxudmFyIExldmVsID0ge1xuICAgIERFQlVHOiAxMCxcbiAgICBJTkZPOiAyMCxcbiAgICBXQVJOOiAzMCxcbiAgICBFUlJPUjogNDAsXG4gICAgRkFUQUw6IDUwLFxufTtcblxuZnVuY3Rpb24gQ29uc29sZVdyaXRlcigpIHt9XG5cbkNvbnNvbGVXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIG91dHB1dDogZnVuY3Rpb24gKGxvZ19uYW1lLCBsZXZlbCwgbWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKGxvZ19uYW1lKSBtZXNzYWdlcy51bnNoaWZ0KGxvZ19uYW1lICsgXCI6XCIpO1xuICAgICAgICBpZiAobGV2ZWwgPD0gTGV2ZWwuREVCVUcpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcgZXhpc3RzIGJ1dCBpcyBkZXByZWNhdGVkXG4gICAgICAgICAgICBtZXNzYWdlcy51bnNoaWZ0KFwiW0RFQlVHXVwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIG1lc3NhZ2VzKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXZlbCA8PSBMZXZlbC5JTkZPKSBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgbWVzc2FnZXMpO1xuICAgICAgICBlbHNlIGlmIChsZXZlbCA8PSBMZXZlbC5XQVJOKSBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgbWVzc2FnZXMpO1xuICAgICAgICBlbHNlIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgbWVzc2FnZXMpO1xuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBMb2dnZXIobmFtZSwgcGFyZW50KSB7XG4gICAgdGhpcy5fbG9nZ2VycyA9IHt9O1xuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJcIjtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBMZXZlbC5XQVJOO1xuICAgIH1cbn1cblxuTG9nZ2VyLnByb3RvdHlwZSA9IHtcbiAgICBnZXRMb2dnZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwYXRoID0gbmFtZS5zcGxpdChcIi5cIiksXG4gICAgICAgICAgICByb290ID0gdGhpcyxcbiAgICAgICAgICAgIHJvdXRlID0gdGhpcy5uYW1lID8gW3RoaXMubmFtZV0gOiBbXTtcbiAgICAgICAgd2hpbGUgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgICAgICByb3V0ZS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIGlmICghKGVudHJ5IGluIHJvb3QuX2xvZ2dlcnMpKVxuICAgICAgICAgICAgICAgIHJvb3QuX2xvZ2dlcnNbZW50cnldID0gbmV3IExvZ2dlcihyb3V0ZS5qb2luKFwiLlwiKSwgcm9vdCk7XG4gICAgICAgICAgICByb290ID0gcm9vdC5fbG9nZ2Vyc1tlbnRyeV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSxcblxuICAgIF9nZXRGbGFnOiBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGZsYWcgPSBcIl9cIiArIGZsYWc7XG4gICAgICAgIHdoaWxlIChjb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dFtmbGFnXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gY29udGV4dFtmbGFnXTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0Ll9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gISFzdGF0ZTtcbiAgICB9LFxuXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2dldEZsYWcoXCJlbmFibGVkXCIpO1xuICAgIH0sXG5cbiAgICBzZXRMZXZlbDogZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIpIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGxldmVsIGluIExldmVsKSB0aGlzLl9sZXZlbCA9IExldmVsW2xldmVsXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRMZXZlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RmxhZyhcImxldmVsXCIpO1xuICAgIH0sXG5cbiAgICBsb2c6IGZ1bmN0aW9uIChsZXZlbCwgbWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1lc3NhZ2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgIXRoaXMuX2dldEZsYWcoXCJlbmFibGVkXCIpIHx8XG4gICAgICAgICAgICBsZXZlbCA8IHRoaXMuX2dldEZsYWcoXCJsZXZlbFwiKVxuICAgICAgICApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1lc3NhZ2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZXMpO1xuICAgICAgICB3cml0ZXIub3V0cHV0KHRoaXMubmFtZSwgbGV2ZWwsIG1lc3NhZ2VzKTtcbiAgICB9LFxuXG4gICAgZGVidWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2coTGV2ZWwuREVCVUcsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGluZm86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2coTGV2ZWwuSU5GTywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgd2FybjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZyhMZXZlbC5XQVJOLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBlcnJvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZyhMZXZlbC5FUlJPUiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgZmF0YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2coTGV2ZWwuRkFUQUwsIGFyZ3VtZW50cyk7XG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIGdldFdyaXRlcigpIHtcbiAgICByZXR1cm4gd3JpdGVyO1xufVxuXG5mdW5jdGlvbiBzZXRXcml0ZXIodykge1xuICAgIHdyaXRlciA9IHc7XG59XG5cbnNldFdyaXRlcihuZXcgQ29uc29sZVdyaXRlcigpKTtcblxucm9vdCA9IG5ldyBMb2dnZXIoKTtcblxudmFyIGxvZ2NvbmZpZyA9IC9sb2dsZXZlbCh8LVtePV0rKT0oW14mXSspL2csXG4gICAgbWF0Y2g7XG5cbndoaWxlICgobWF0Y2ggPSBsb2djb25maWcuZXhlYyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKSkgIT09IG51bGwpIHtcbiAgICB2YXIgbG9nZ2VyID0gbWF0Y2hbMV0gPT09IFwiXCIgPyByb290IDogcm9vdC5nZXRMb2dnZXIobWF0Y2hbMV0uc2xpY2UoMSkpO1xuICAgIGxvZ2dlci5zZXRMZXZlbChtYXRjaFsyXS50b1VwcGVyQ2FzZSgpKTtcbn1cblxudmFyIGFwaSA9IHtcbiAgICBMZXZlbDogTGV2ZWwsXG4gICAgZ2V0TG9nZ2VyOiByb290LmdldExvZ2dlci5iaW5kKHJvb3QpLFxuICAgIHNldEVuYWJsZWQ6IHJvb3Quc2V0RW5hYmxlZC5iaW5kKHJvb3QpLFxuICAgIGlzRW5hYmxlZDogcm9vdC5pc0VuYWJsZWQuYmluZChyb290KSxcbiAgICBzZXRMZXZlbDogcm9vdC5zZXRMZXZlbC5iaW5kKHJvb3QpLFxuICAgIGdldExldmVsOiByb290LmdldExldmVsLmJpbmQocm9vdCksXG4gICAgZGVidWc6IHJvb3QuZGVidWcuYmluZChyb290KSxcbiAgICBpbmZvOiByb290LmluZm8uYmluZChyb290KSxcbiAgICB3YXJuOiByb290Lndhcm4uYmluZChyb290KSxcbiAgICBlcnJvcjogcm9vdC5lcnJvci5iaW5kKHJvb3QpLFxuICAgIGZhdGFsOiByb290LmZhdGFsLmJpbmQocm9vdCksXG4gICAgZ2V0V3JpdGVyOiBnZXRXcml0ZXIsXG4gICAgc2V0V3JpdGVyOiBzZXRXcml0ZXIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBhcGk7XG4iLCIvKipcbiAqIFBhdHRlcm5zIHJlZ2lzdHJ5IC0gQ2VudHJhbCByZWdpc3RyeSBhbmQgc2NhbiBsb2dpYyBmb3IgcGF0dGVybnNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFNpbXBsb24gQi5WLlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBGbG9yaWFuIEZyaWVzZG9yZlxuICogQ29weXJpZ2h0IDIwMTMgTWFya28gRHVya292aWNcbiAqIENvcHlyaWdodCAyMDEzIFJvayBHYXJiYXNcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUgU3lzbGFiLmNvbSBHbUJILCBKQyBCcmFuZFxuICovXG5cbi8qXG4gKiBjaGFuZ2VzIHRvIHByZXZpb3VzIHBhdHRlcm5zLnJlZ2lzdGVyL3NjYW4gbWVjaGFuaXNtXG4gKiAtIGlmIHlvdSB3YW50IGluaXRpYWxpc2VkIGNsYXNzLCBkbyBpdCBpbiBpbml0XG4gKiAtIGluaXQgcmV0dXJucyBzZXQgb2YgZWxlbWVudHMgYWN0dWFsbHkgaW5pdGlhbGlzZWRcbiAqIC0gaGFuZGxlIG9uY2Ugd2l0aGluIGluaXRcbiAqIC0gbm8gdHVybnN0aWxlIGFueW1vcmVcbiAqIC0gc2V0IHBhdHRlcm4uanF1ZXJ5X3BsdWdpbiBpZiB5b3Ugd2FudCBpdFxuICovXG5pbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XG5pbXBvcnQgZG9tIGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IGxvZ2dpbmcgZnJvbSBcIi4vbG9nZ2luZ1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IGxvZyA9IGxvZ2dpbmcuZ2V0TG9nZ2VyKFwicmVnaXN0cnlcIik7XG5jb25zdCBkaXNhYmxlX3JlID0gL3BhdHRlcm5zLWRpc2FibGU9KFteJl0rKS9nO1xuY29uc3QgZG9udF9jYXRjaF9yZSA9IC9wYXR0ZXJucy1kb250LWNhdGNoL2c7XG5jb25zdCBkaXNhYmxlZCA9IHt9O1xubGV0IGRvbnRfY2F0Y2ggPSBmYWxzZTtcbmxldCBtYXRjaDtcblxud2hpbGUgKChtYXRjaCA9IGRpc2FibGVfcmUuZXhlYyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKSkgIT09IG51bGwpIHtcbiAgICBkaXNhYmxlZFttYXRjaFsxXV0gPSB0cnVlO1xuICAgIGxvZy5pbmZvKFwiUGF0dGVybiBkaXNhYmxlZCB2aWEgdXJsIGNvbmZpZzpcIiwgbWF0Y2hbMV0pO1xufVxuXG53aGlsZSAoKG1hdGNoID0gZG9udF9jYXRjaF9yZS5leGVjKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpKSAhPT0gbnVsbCkge1xuICAgIGRvbnRfY2F0Y2ggPSB0cnVlO1xuICAgIGxvZy5pbmZvKFwiSSB3aWxsIG5vdCBjYXRjaCBpbml0IGV4Y2VwdGlvbnNcIik7XG59XG5cbi8qKlxuICogR2xvYmFsIHBhdHRlcm4gcmVnaXN0cnkuXG4gKlxuICogVGhpcyBpcyBhIHNpbmdsZXRvbiBhbmQgc2hhcmVkIGFtb25nIGFueSBpbnN0YW5jZSBvZiB0aGUgUGF0dGVybnNsaWJcbiAqIHJlZ2lzdHJ5IHNpbmNlIFBhdHRlcm5zbGliIHZlcnNpb24gOC5cbiAqXG4gKiBZb3Ugbm9ybWFsbHkgZG9uJ3QgbmVlZCB0aGlzIGFzIHRoZSByZWdpc3RyeSBoYW5kbGVzIGl0IGZvciB5b3UuXG4gKi9cbmlmICh0eXBlb2Ygd2luZG93Ll9fcGF0dGVybnNsaWJfcmVnaXN0cnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cuX19wYXR0ZXJuc2xpYl9yZWdpc3RyeSA9IHt9O1xufVxuZXhwb3J0IGNvbnN0IFBBVFRFUk5fUkVHSVNUUlkgPSB3aW5kb3cuX19wYXR0ZXJuc2xpYl9yZWdpc3RyeTtcbmlmICh0eXBlb2Ygd2luZG93Ll9fcGF0dGVybnNsaWJfcmVnaXN0cnlfaW5pdGlhbGl6ZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cuX19wYXR0ZXJuc2xpYl9yZWdpc3RyeV9pbml0aWFsaXplZCA9IGZhbHNlO1xufVxuXG5jb25zdCByZWdpc3RyeSA9IHtcbiAgICBwYXR0ZXJuczogUEFUVEVSTl9SRUdJU1RSWSwgLy8gcmVmZXJlbmNlIHRvIGdsb2JhbCBwYXR0ZXJucyByZWdpc3RyeVxuICAgIC8vIGFzIGxvbmcgYXMgdGhlIHJlZ2lzdHJ5IGlzIG5vdCBpbml0aWFsaXplZCwgcGF0dGVyblxuICAgIC8vIHJlZ2lzdHJhdGlvbiBqdXN0IHJlZ2lzdGVycyBhIHBhdHRlcm4uIE9uY2UgaW5pdCBpcyBjYWxsZWQsXG4gICAgLy8gdGhlIERPTSBpcyBzY2FubmVkLiBBZnRlciB0aGF0IHJlZ2lzdGVyaW5nIGEgbmV3IHBhdHRlcm5cbiAgICAvLyByZXN1bHRzIGluIHJlc2Nhbm5pbmcgdGhlIERPTSBvbmx5IGZvciB0aGlzIHBhdHRlcm4uXG4gICAgaW5pdCgpIHtcbiAgICAgICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5fX3BhdHRlcm5zbGliX3JlZ2lzdHJ5X2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHJlaW5pdGlhbGl6ZSBhIGFscmVhZHkgaW5pdGlhbGl6ZWQgcmVnaXN0cnkuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93Ll9fcGF0dGVybnNsaWJfcmVnaXN0cnlfaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiTG9hZGVkOiBcIiArIE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBhdHRlcm5zKS5zb3J0KCkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LnNjYW4oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJGaW5pc2hlZCBpbml0aWFsIHNjYW4uXCIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIC8vIFJlbW92ZXMgYWxsIHBhdHRlcm5zIGZyb20gdGhlIHJlZ2lzdHJ5LiBDdXJyZW50bHkgb25seSBiZWluZ1xuICAgICAgICAvLyB1c2VkIGluIHRlc3RzLlxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcmVnaXN0cnkucGF0dGVybnMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZWdpc3RyeS5wYXR0ZXJuc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm1QYXR0ZXJuKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgLyogQ2FsbCB0aGUgdHJhbnNmb3JtIG1ldGhvZCBvbiB0aGUgcGF0dGVybiB3aXRoIHRoZSBnaXZlbiBuYW1lLCBpZlxuICAgICAgICAgKiBpdCBleGlzdHMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZGlzYWJsZWRbbmFtZV0pIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgU2tpcHBpbmcgZGlzYWJsZWQgcGF0dGVybjogJHtuYW1lfS5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSByZWdpc3RyeS5wYXR0ZXJuc1tuYW1lXTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gcGF0dGVybi50cmFuc2Zvcm0gfHwgcGF0dGVybi5wcm90b3R5cGU/LnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0oJChjb250ZW50KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbnRfY2F0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKGBUcmFuc2Zvcm0gZXJyb3IgZm9yIHBhdHRlcm4gJHtuYW1lfS5gLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0UGF0dGVybihuYW1lLCBlbCwgdHJpZ2dlcikge1xuICAgICAgICAvKiBJbml0aWFsaXplIHRoZSBwYXR0ZXJuIHdpdGggdGhlIHByb3ZpZGVkIG5hbWUgYW5kIGluIHRoZSBjb250ZXh0XG4gICAgICAgICAqIG9mIHRoZSBwYXNzZWQgaW4gRE9NIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHJlZ2lzdHJ5LnBhdHRlcm5zW25hbWVdO1xuICAgICAgICBpZiAocGF0dGVybi5pbml0KSB7XG4gICAgICAgICAgICBjb25zdCBwbG9nID0gbG9nZ2luZy5nZXRMb2dnZXIoYHBhdC4ke25hbWV9YCk7XG4gICAgICAgICAgICBpZiAoJGVsLmlzKHBhdHRlcm4udHJpZ2dlcikpIHtcbiAgICAgICAgICAgICAgICBwbG9nLmRlYnVnKFwiSW5pdGlhbGlzaW5nLlwiLCAkZWwpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uaW5pdCgkZWwsIG51bGwsIHRyaWdnZXIpO1xuICAgICAgICAgICAgICAgICAgICBwbG9nLmRlYnVnKFwiZG9uZS5cIik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9udF9jYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwbG9nLmVycm9yKFwiQ2F1Z2h0IGVycm9yOlwiLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3JkZXJQYXR0ZXJucyhwYXR0ZXJucykge1xuICAgICAgICAvLyBYWFg6IEJpdCBvZiBhIGhhY2suIFdlIG5lZWQgdGhlIHZhbGlkYXRpb24gcGF0dGVybiB0byBiZVxuICAgICAgICAvLyBwYXJzZWQgYW5kIGluaXRpYXRlZCBiZWZvcmUgdGhlIGluamVjdCBwYXR0ZXJuLiBTbyB3ZSBtYWtlXG4gICAgICAgIC8vIHN1cmUgaGVyZSwgdGhhdCBpdCBhcHBlYXJzIGZpcnN0LiBOb3Qgc3VyZSB3aGF0IHdvdWxkIGJlXG4gICAgICAgIC8vIHRoZSBiZXN0IHNvbHV0aW9uLiBQZXJoYXBzIHNvbWUga2luZCBvZiB3YXkgdG8gcmVnaXN0ZXJcbiAgICAgICAgLy8gcGF0dGVybnMgXCJiZWZvcmVcIiBvciBcImFmdGVyXCIgb3RoZXIgcGF0dGVybnMuXG4gICAgICAgIGlmIChwYXR0ZXJucy5pbmNsdWRlcyhcInZhbGlkYXRpb25cIikgJiYgcGF0dGVybnMuaW5jbHVkZXMoXCJpbmplY3RcIikpIHtcbiAgICAgICAgICAgIHBhdHRlcm5zLnNwbGljZShwYXR0ZXJucy5pbmRleE9mKFwidmFsaWRhdGlvblwiKSwgMSk7XG4gICAgICAgICAgICBwYXR0ZXJucy51bnNoaWZ0KFwidmFsaWRhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybnM7XG4gICAgfSxcblxuICAgIHNjYW4oY29udGVudCwgcGF0dGVybnMsIHRyaWdnZXIpIHtcbiAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnQuanF1ZXJ5KSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IFtdO1xuICAgICAgICBwYXR0ZXJucyA9IHRoaXMub3JkZXJQYXR0ZXJucyhwYXR0ZXJucyB8fCBPYmplY3Qua2V5cyhyZWdpc3RyeS5wYXR0ZXJucykpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtUGF0dGVybihuYW1lLCBjb250ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSByZWdpc3RyeS5wYXR0ZXJuc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLnRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMudW5zaGlmdChwYXR0ZXJuLnRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1hdGNoZXMgPSBkb20ucXVlcnlTZWxlY3RvckFsbEFuZE1lKFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIHNlbGVjdG9ycy5tYXAoKGl0KSA9PiBpdC50cmltKCkucmVwbGFjZSgvLCQvLCBcIlwiKSkuam9pbihcIixcIilcbiAgICAgICAgKTtcbiAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMuZmlsdGVyKChlbCkgPT4ge1xuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBwYXR0ZXJuczpcbiAgICAgICAgICAgIC8vIC0gd2l0aCBjbGFzcyBgYC5kaXNhYmxlLXBhdHRlcm5zYGBcbiAgICAgICAgICAgIC8vIC0gd3JhcHBlZCBpbiBgYC5kaXNhYmxlLXBhdHRlcm5zYGAgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIC0gd3JhcHBlZCBpbiBgYDxwcmU+YGAgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIC0gd3JhcHBlZCBpbiBgYDx0ZW1wbGF0ZT5gYCBlbGVtZW50c1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAhZWwubWF0Y2hlcyhcIi5kaXNhYmxlLXBhdHRlcm5zXCIpICYmXG4gICAgICAgICAgICAgICAgIWVsPy5wYXJlbnROb2RlPy5jbG9zZXN0Py4oXCIuZGlzYWJsZS1wYXR0ZXJuc1wiKSAmJlxuICAgICAgICAgICAgICAgICFlbD8ucGFyZW50Tm9kZT8uY2xvc2VzdD8uKFwicHJlXCIpICYmXG4gICAgICAgICAgICAgICAgIWVsPy5wYXJlbnROb2RlPy5jbG9zZXN0Py4oXCJ0ZW1wbGF0ZVwiKSAmJiAvLyBOT1RFOiBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5LiBUZW1wbGF0ZSBpcyBhIERvY3VtZW50RnJhZ21lbnQgYW5kIG5vdCByZWFjaGFibGUgZXhjZXB0IGZvciBJRS5cbiAgICAgICAgICAgICAgICAhZWwubWF0Y2hlcyhcIi5jYW50LXRvdWNoLXRoaXNcIikgJiYgLy8gQkJCLiBUT0RPOiBSZW1vdmUgd2l0aCBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAgICAgICAgICAgICAgIWVsPy5wYXJlbnROb2RlPy5jbG9zZXN0Py4oXCIuY2FudC10b3VjaC10aGlzXCIpIC8vIEJCQi4gVE9ETzogUmVtb3ZlIHdpdGggbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gd2FsayBsaXN0IGJhY2t3YXJkcyBhbmQgaW5pdGlhbGl6ZSBwYXR0ZXJucyBpbnNpZGUtb3V0LlxuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIG1hdGNoZXMucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRQYXR0ZXJuKG5hbWUsIGVsLCB0cmlnZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJwYXR0ZXJucy1sb2FkZWRcIik7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyKHBhdHRlcm4sIG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgcGF0dGVybi5uYW1lO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIlBhdHRlcm4gbGFja3MgYSBuYW1lLlwiLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVnaXN0cnkucGF0dGVybnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgQWxyZWFkeSBoYXZlIGEgcGF0dGVybiBjYWxsZWQgJHtuYW1lfS5gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWdpc3RlciBwYXR0ZXJuIHRvIGJlIHVzZWQgZm9yIHNjYW5uaW5nIG5ldyBjb250ZW50XG4gICAgICAgIHJlZ2lzdHJ5LnBhdHRlcm5zW25hbWVdID0gcGF0dGVybjtcblxuICAgICAgICAvLyByZWdpc3RlciBwYXR0ZXJuIGFzIGpxdWVyeSBwbHVnaW5cbiAgICAgICAgaWYgKHBhdHRlcm4uanF1ZXJ5X3BsdWdpbikge1xuICAgICAgICAgICAgY29uc3QgcGx1Z2luX25hbWUgPSAoXCJwYXQtXCIgKyBuYW1lKS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8tKFthLXpBLVpdKS9nLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChtYXRjaCwgcDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICQuZm5bcGx1Z2luX25hbWVdID0gdXRpbHMuanF1ZXJ5UGx1Z2luKHBhdHRlcm4pO1xuICAgICAgICAgICAgLy8gQkJCIDIwMTItMTItMTAgYW5kIGFsc28gZm9yIE1vY2t1cCBwYXR0ZXJucy5cbiAgICAgICAgICAgICQuZm5bcGx1Z2luX25hbWUucmVwbGFjZSgvXnBhdC8sIFwicGF0dGVyblwiKV0gPSAkLmZuW3BsdWdpbl9uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuZGVidWcoYFJlZ2lzdGVyZWQgcGF0dGVybiAke25hbWV9YCwgcGF0dGVybik7XG4gICAgICAgIGlmICh3aW5kb3cuX19wYXR0ZXJuc2xpYl9yZWdpc3RyeV9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgLy8gT25jZSB0aGUgZmlyc3QgaW5pdGlhbGl6YXRpb24gaGFzIGJlZW4gZG9uZSwgZG8gb25seSBzY2FuIGZvclxuICAgICAgICAgICAgLy8gbmV3bHkgcmVnaXN0ZXJlZCBwYXR0ZXJucy5cbiAgICAgICAgICAgIHJlZ2lzdHJ5LnNjYW4oZG9jdW1lbnQuYm9keSwgW25hbWVdKTtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgUmUtc2Nhbm5lZCBkb20gd2l0aCBuZXdseSByZWdpc3RlcmVkIHBhdHRlcm4gJHtuYW1lfS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVnaXN0cnk7XG4iLCJpbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XG5pbXBvcnQgZG9tIGZyb20gXCIuL2RvbVwiO1xuXG4kLmZuLnNhZmVDbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGNsb25lID0gdGhpcy5jbG9uZSgpO1xuICAgIC8vIElFIEJVRyA6IFBsYWNlaG9sZGVyIHRleHQgYmVjb21lcyBhY3R1YWwgdmFsdWUgYWZ0ZXIgZGVlcCBjbG9uZSBvbiB0ZXh0YXJlYVxuICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvNzgxNjEyL3BsYWNlaG9sZGVyLXRleHQtYmVjb21lcy1hY3R1YWwtdmFsdWUtYWZ0ZXItZGVlcC1jbG9uZS1vbi10ZXh0YXJlYVxuICAgIGlmICh3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7XG4gICAgICAgICRjbG9uZS5maW5kSW5jbHVzaXZlKFwiOmlucHV0W3BsYWNlaG9sZGVyXVwiKS5lYWNoKGZ1bmN0aW9uIChpLCBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgJGl0ZW0gPSAkKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKCRpdGVtLmF0dHIoXCJwbGFjZWhvbGRlclwiKSA9PT0gJGl0ZW0udmFsKCkpIHtcbiAgICAgICAgICAgICAgICAkaXRlbS52YWwoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJGNsb25lO1xufTtcblxuLy8gUHJvZHVjdGlvbiBzdGVwcyBvZiBFQ01BLTI2MiwgRWRpdGlvbiA1LCAxNS40LjQuMThcbi8vIFJlZmVyZW5jZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMThcbmlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgVCwgaztcbiAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCIgdGhpcyBpcyBudWxsIG9yIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDEuIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCBwYXNzaW5nIHRoZSB8dGhpc3wgdmFsdWUgYXMgdGhlIGFyZ3VtZW50LlxuICAgICAgICB2YXIgTyA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgLy8gMi4gTGV0IGxlblZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggdGhlIGFyZ3VtZW50IFwibGVuZ3RoXCIuXG4gICAgICAgIC8vIDMuIExldCBsZW4gYmUgVG9VaW50MzIobGVuVmFsdWUpLlxuICAgICAgICB2YXIgbGVuID0gTy5sZW5ndGggPj4+IDA7XG4gICAgICAgIC8vIDQuIElmIElzQ2FsbGFibGUoY2FsbGJhY2spIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIC8vIFNlZTogaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS4xMVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA1LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgVCA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4gTGV0IGsgYmUgMFxuICAgICAgICBrID0gMDtcbiAgICAgICAgLy8gNy4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXG4gICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIga1ZhbHVlO1xuICAgICAgICAgICAgLy8gYS4gTGV0IFBrIGJlIFRvU3RyaW5nKGspLlxuICAgICAgICAgICAgLy8gICBUaGlzIGlzIGltcGxpY2l0IGZvciBMSFMgb3BlcmFuZHMgb2YgdGhlIGluIG9wZXJhdG9yXG4gICAgICAgICAgICAvLyBiLiBMZXQga1ByZXNlbnQgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBIYXNQcm9wZXJ0eSBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgICAgICAgLy8gICBUaGlzIHN0ZXAgY2FuIGJlIGNvbWJpbmVkIHdpdGggY1xuICAgICAgICAgICAgLy8gYy4gSWYga1ByZXNlbnQgaXMgdHJ1ZSwgdGhlblxuICAgICAgICAgICAgaWYgKGsgaW4gTykge1xuICAgICAgICAgICAgICAgIC8vIGkuIExldCBrVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cbiAgICAgICAgICAgICAgICBrVmFsdWUgPSBPW2tdO1xuICAgICAgICAgICAgICAgIC8vIGlpLiBDYWxsIHRoZSBDYWxsIGludGVybmFsIG1ldGhvZCBvZiBjYWxsYmFjayB3aXRoIFQgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gYXJndW1lbnQgbGlzdCBjb250YWluaW5nIGtWYWx1ZSwgaywgYW5kIE8uXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChULCBrVmFsdWUsIGssIE8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZC4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIC8vIDguIHJldHVybiB1bmRlZmluZWRcbiAgICB9O1xufVxuXG52YXIgc2luZ2xlQm91bmRKUXVlcnlQbHVnaW4gPSBmdW5jdGlvbiAocGF0dGVybiwgbWV0aG9kLCBvcHRpb25zKSB7XG4gICAgLyogVGhpcyBpcyBhIGpRdWVyeSBwbHVnaW4gZm9yIHBhdHRlcm5zIHdoaWNoIGFyZSBpbnZva2VkIE9OQ0UgRk9SIEVBQ0hcbiAgICAgKiBtYXRjaGVkIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaG93IHRoZSBNb2NrdXAtdHlwZSBwYXR0ZXJucyBiZWhhdmUuIFRoZXkgYXJlIGNvbnN0cnVjdG9yXG4gICAgICogZnVuY3Rpb25zIHdoaWNoIG5lZWQgdG8gYmUgaW52b2tlZCBvbmNlIHBlciBqUXVlcnktd3JhcHBlZCBET00gbm9kZVxuICAgICAqIGZvciBhbGwgRE9NIG5vZGVzIG9uIHdoaWNoIHRoZSBwYXR0ZXJuIGFwcGxpZXMuXG4gICAgICovXG4gICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAkdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdCxcbiAgICAgICAgICAgICRlbCA9ICQodGhpcyk7XG4gICAgICAgIHBhdCA9IHBhdHRlcm4uaW5pdCgkZWwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAocGF0W21ldGhvZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiTWV0aG9kIFwiICsgbWV0aG9kICsgXCIgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LlwiICsgcGF0dGVybi5uYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWV0aG9kLmNoYXJBdCgwKSA9PT0gXCJfXCIpIHtcbiAgICAgICAgICAgICAgICAkLmVycm9yKFwiTWV0aG9kIFwiICsgbWV0aG9kICsgXCIgaXMgcHJpdmF0ZSBvbiBqUXVlcnkuXCIgKyBwYXR0ZXJuLm5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdFttZXRob2RdLmFwcGx5KHBhdCwgW29wdGlvbnNdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAkdGhpcztcbn07XG5cbnZhciBwbHVyYWxCb3VuZEpRdWVyeVBsdWdpbiA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBtZXRob2QsIG9wdGlvbnMpIHtcbiAgICAvKiBUaGlzIGlzIGEgalF1ZXJ5IHBsdWdpbiBmb3IgcGF0dGVybnMgd2hpY2ggYXJlIGludm9rZWQgT05DRSBGT1IgQUxMXG4gICAgICogbWF0Y2hlZCBlbGVtZW50cyBpbiB0aGUgRE9NLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBob3cgdGhlIHZhbmlsbGEgUGF0dGVybnNsaWItdHlwZSBwYXR0ZXJucyBiZWhhdmUuIFRoZXkgYXJlXG4gICAgICogc2ltcGxlIG9iamVjdHMgd2l0aCBhbiBpbml0IG1ldGhvZCBhbmQgdGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgb25jZVxuICAgICAqIHdpdGggYSBsaXN0IG9mIGpRdWVyeS13cmFwcGVkIERPTSBub2RlcyBvbiB3aGljaCB0aGUgcGF0dGVyblxuICAgICAqIGFwcGxpZXMuXG4gICAgICovXG4gICAgdmFyICR0aGlzID0gdGhpcztcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuW21ldGhvZF0uYXBwbHkoJHRoaXMsIFskdGhpc10uY29uY2F0KFtvcHRpb25zXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5lcnJvcihcIk1ldGhvZCBcIiArIG1ldGhvZCArIFwiIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS5cIiArIHBhdHRlcm4ubmFtZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuLmluaXQuYXBwbHkoJHRoaXMsIFskdGhpc10uY29uY2F0KFtvcHRpb25zXSkpO1xuICAgIH1cbiAgICByZXR1cm4gJHRoaXM7XG59O1xuXG52YXIganF1ZXJ5UGx1Z2luID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoJHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBtZXRob2Q7XG4gICAgICAgICAgICBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGVCb3VuZEpRdWVyeVBsdWdpbi5jYWxsKHRoaXMsIHBhdHRlcm4sIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGx1cmFsQm91bmRKUXVlcnlQbHVnaW4uY2FsbCh0aGlzLCBwYXR0ZXJuLCBtZXRob2QsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgISFvYmopO1xufVxuXG4vLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbmZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuLy8gRU5EOiBUYWtlbiBmcm9tIFVuZGVyc2NvcmUuanMgdW50aWwgaGVyZS5cblxuZnVuY3Rpb24gcmViYXNlVVJMKGJhc2UsIHVybCkge1xuICAgIGJhc2UgPSBuZXcgVVJMKGJhc2UsIHdpbmRvdy5sb2NhdGlvbikuaHJlZjsgLy8gSWYgYmFzZSBpcyByZWxhdGl2ZSBtYWtlIGl0IGFic29sdXRlLlxuICAgIGlmICh1cmwuaW5kZXhPZihcIjovL1wiKSAhPT0gLTEgfHwgdXJsWzBdID09PSBcIi9cIiB8fCB1cmwuaW5kZXhPZihcImRhdGE6XCIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLnNsaWNlKDAsIGJhc2UubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyB1cmw7XG59XG5cbmZ1bmN0aW9uIGZpbmRMYWJlbChpbnB1dCkge1xuICAgIHZhciAkbGFiZWw7XG4gICAgZm9yIChcbiAgICAgICAgdmFyIGxhYmVsID0gaW5wdXQucGFyZW50Tm9kZTtcbiAgICAgICAgbGFiZWwgJiYgbGFiZWwubm9kZVR5cGUgIT09IDExO1xuICAgICAgICBsYWJlbCA9IGxhYmVsLnBhcmVudE5vZGVcbiAgICApIHtcbiAgICAgICAgaWYgKGxhYmVsLnRhZ05hbWUgPT09IFwiTEFCRUxcIikge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dC5pZCkge1xuICAgICAgICAkbGFiZWwgPSAkKCdsYWJlbFtmb3I9XCInICsgaW5wdXQuaWQgKyAnXCJdJyk7XG4gICAgfVxuICAgIGlmICgkbGFiZWwgJiYgJGxhYmVsLmxlbmd0aCA9PT0gMCAmJiBpbnB1dC5mb3JtKSB7XG4gICAgICAgICRsYWJlbCA9ICQoJ2xhYmVsW2Zvcj1cIicgKyBpbnB1dC5uYW1lICsgJ1wiXScsIGlucHV0LmZvcm0pO1xuICAgIH1cbiAgICBpZiAoJGxhYmVsICYmICRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICRsYWJlbFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjM5OTkvaG93LXRvLXRlbGwtaWYtYS1kb20tZWxlbWVudC1pcy12aXNpYmxlLWluLXRoZS1jdXJyZW50LXZpZXdwb3J0XG5mdW5jdGlvbiBlbGVtZW50SW5WaWV3cG9ydChlbCkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICB2V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2NFbC5jbGllbnRXaWR0aCxcbiAgICAgICAgdkhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2NFbC5jbGllbnRIZWlnaHQ7XG5cbiAgICBpZiAocmVjdC5yaWdodCA8IDAgfHwgcmVjdC5ib3R0b20gPCAwIHx8IHJlY3QubGVmdCA+IHZXaWR0aCB8fCByZWN0LnRvcCA+IHZIZWlnaHQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM0NDYxNzAvZXNjYXBlLXN0cmluZy1mb3ItdXNlLWluLWphdmFzY3JpcHQtcmVnZXhcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3NlcyBmcm9tIGEgbGlzdCBvZiB0YXJnZXRzIGlmIHRoZXkgbWF0Y2ggYSBzcGVjaWZpYyBwYXR0ZXJuLlxuICpcbiAqIEBwYXJhbSB7Tm9kZSwgTm9kZUxpc3R9IHRhcmdldHM6IERvbSBOb2RlIG9yIE5vZGVMaXN0IHdoZXJlIHRoZSBjbGFzc2VzIHNob3VsZCBiZSByZW1vdmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXM6IFN0cmluZyBtYXRjaGluZyBjbGFzc2VzIHRvIGJlIHJlbW92ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBhZGQgYSBcIipcIiBhcyB3aWxkY2FyZCB0byBzZWFyY2ggZm9yIGNsYXNzZXMgdG8gYmUgcmVtb3ZlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBFLmcuIFwiaWNvbi0qLWFsZXJ0XCIgdG8gcmVtb3ZlIGFueSBvZiBcImljb24tMS1hbGVydCBpY29uLTItYWxlcnRcIi5cbiAqXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfTogVGhpcyBtZXRob2QgZGlyZWN0bHkgb3BlcmF0ZXMgb24gdGhlIHRhcmdldHMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVdpbGRjYXJkQ2xhc3ModGFyZ2V0cywgY2xhc3Nlcykge1xuICAgIHRhcmdldHMgPSB1dGlscy5lbnN1cmVBcnJheSh0YXJnZXRzKTtcblxuICAgIGlmIChjbGFzc2VzLmluZGV4T2YoXCIqXCIpID09PSAtMSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBtYXRjaGVyID0gY2xhc3Nlcy5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSs/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgbWF0Y2hlciA9IG1hdGNoZXIucmVwbGFjZSgvWypdL2csIFwiLipcIik7XG4gICAgICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbWF0Y2hlciArIFwiJFwiKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc19saXN0ID0gKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgaWYgKCFjbGFzc19saXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2sgPSBjbGFzc19saXN0LmZpbHRlcigoaXQpID0+ICFtYXRjaGVyLnRlc3QoaXQpKTtcbiAgICAgICAgICAgIGlmIChvay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgb2suam9pbihcIiBcIikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbHVlKGVsKSB7XG4gICAgaWYgKGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIikge1xuICAgICAgICBpZiAoZWwudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IGVsLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsLnZhbHVlICE9PSBcIlwiO1xuICAgIH1cbiAgICBpZiAoZWwudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICAgICAgICByZXR1cm4gZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTE7XG4gICAgfVxuICAgIGlmIChlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgcmV0dXJuIGVsLnZhbHVlICE9PSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IGhpZGVPclNob3cgPSAobm9kZXMsIHZpc2libGUsIG9wdGlvbnMsIHBhdHRlcm5fbmFtZSkgPT4ge1xuICAgIG5vZGVzID0gZG9tLnRvTm9kZUFycmF5KG5vZGVzKTtcblxuICAgIGNvbnN0IHRyYW5zaXRpb25zID0ge1xuICAgICAgICBub25lOiB7IGhpZGU6IFwiaGlkZVwiLCBzaG93OiBcInNob3dcIiB9LFxuICAgICAgICBmYWRlOiB7IGhpZGU6IFwiZmFkZU91dFwiLCBzaG93OiBcImZhZGVJblwiIH0sXG4gICAgICAgIHNsaWRlOiB7IGhpZGU6IFwic2xpZGVVcFwiLCBzaG93OiBcInNsaWRlRG93blwiIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGR1cmF0aW9uID1cbiAgICAgICAgb3B0aW9ucy50cmFuc2l0aW9uID09PSBcImNzc1wiIHx8IG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gXCJub25lXCJcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBvcHRpb25zLmVmZmVjdC5kdXJhdGlvbjtcblxuICAgIGNvbnN0IG9uX2NvbXBsZXRlID0gKGVsKSA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJpbi1wcm9ncmVzc1wiKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh2aXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKTtcbiAgICAgICAgJChlbCkudHJpZ2dlcihcInBhdC11cGRhdGVcIiwge1xuICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybl9uYW1lLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogXCJjb21wbGV0ZVwiLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBlbCBvZiBub2Rlcykge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwidmlzaWJsZVwiKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcImluLXByb2dyZXNzXCIpO1xuXG4gICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRyYW5zaXRpb25zW29wdGlvbnMudHJhbnNpdGlvbl07XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKFwiaW4tcHJvZ3Jlc3NcIik7XG4gICAgICAgICAgICAkKGVsKS50cmlnZ2VyKFwicGF0LXVwZGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybl9uYW1lLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IFwic3RhcnRcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJChlbClbdmlzaWJsZSA/IHQuc2hvdyA6IHQuaGlkZV0oe1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWZmZWN0LmVhc2luZyxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogKCkgPT4gb25fY29tcGxldGUoZWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uICE9PSBcImNzc1wiKSB7XG4gICAgICAgICAgICAgICAgZG9tW3Zpc2libGUgPyBcInNob3dcIiA6IFwiaGlkZVwiXShlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbl9jb21wbGV0ZShlbCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBhZGRVUkxRdWVyeVBhcmFtZXRlcihmdWxsVVJMLCBwYXJhbSwgdmFsdWUpIHtcbiAgICAvKiBVc2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCAoPz1cXD0pIHRvIGZpbmQgdGhlIGdpdmVuIHBhcmFtZXRlcixcbiAgICAgKiBwcmVjZWRlZCBieSBhID8gb3IgJiwgYW5kIGZvbGxvd2VkIGJ5IGEgPSB3aXRoIGEgdmFsdWUgYWZ0ZXJcbiAgICAgKiB0aGFuICh1c2luZyBhIG5vbi1ncmVlZHkgc2VsZWN0b3IpIGFuZCB0aGVuIGZvbGxvd2VkIGJ5XG4gICAgICogYSAmIG9yIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjQwMjcwL2FkZGluZy1tb2RpZnktcXVlcnktc3RyaW5nLWdldC12YXJpYWJsZXMtaW4tYS11cmwtd2l0aC1qYXZhc2NyaXB0XG4gICAgICovXG4gICAgdmFyIHZhbCA9IG5ldyBSZWdFeHAoXCIoXFxcXD98XFxcXCYpXCIgKyBwYXJhbSArIFwiPS4qPyg/PSgmfCQpKVwiKSxcbiAgICAgICAgcGFydHMgPSBmdWxsVVJMLnRvU3RyaW5nKCkuc3BsaXQoXCIjXCIpLFxuICAgICAgICB1cmwgPSBwYXJ0c1swXSxcbiAgICAgICAgaGFzaCA9IHBhcnRzWzFdLFxuICAgICAgICBxc3RyaW5nID0gL1xcPy4rJC8sXG4gICAgICAgIG5ld1VSTCA9IHVybDtcbiAgICAvLyBDaGVjayBpZiB0aGUgcGFyYW1ldGVyIGV4aXN0c1xuICAgIGlmICh2YWwudGVzdCh1cmwpKSB7XG4gICAgICAgIC8vIGlmIGl0IGRvZXMsIHJlcGxhY2UgaXQsIHVzaW5nIHRoZSBjYXB0dXJlZCBncm91cFxuICAgICAgICAvLyB0byBkZXRlcm1pbmUgJiBvciA/IGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgbmV3VVJMID0gdXJsLnJlcGxhY2UodmFsLCBcIiQxXCIgKyBwYXJhbSArIFwiPVwiICsgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocXN0cmluZy50ZXN0KHVybCkpIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhIHF1ZXJ5IHN0cmluZyBhdCBhbGxcbiAgICAgICAgLy8gYWRkIHRoZSBwYXJhbSB0byB0aGUgZW5kIG9mIGl0XG4gICAgICAgIG5ld1VSTCA9IHVybCArIFwiJlwiICsgcGFyYW0gKyBcIj1cIiArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gcXVlcnkgc3RyaW5nLCBhZGQgb25lXG4gICAgICAgIG5ld1VSTCA9IHVybCArIFwiP1wiICsgcGFyYW0gKyBcIj1cIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaGFzaCkge1xuICAgICAgICBuZXdVUkwgKz0gXCIjXCIgKyBoYXNoO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VVJMO1xufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVPYmplY3RzKG9ianMpIHtcbiAgICAvKiBHaXZlbiBhbiBhcnJheSBvZiBvYmplY3RzLCByZW1vdmUgYW55IGR1cGxpY2F0ZSBvYmplY3RzIHdoaWNoIG1pZ2h0XG4gICAgICogYmUgcHJlc2VudC5cbiAgICAgKi9cbiAgICBjb25zdCBjb21wYXJhdG9yID0gZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba10gPT09IHY7XG4gICAgfTtcblxuICAgIHJldHVybiBvYmpzLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgbmV4dF9vYmopIHtcbiAgICAgICAgbGV0IGlzX2R1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBsaXN0KSB7XG4gICAgICAgICAgICBpc19kdXBsaWNhdGUgPVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSBPYmplY3Qua2V5cyhuZXh0X29iaikubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgIChpdCkgPT4gIWNvbXBhcmF0b3IuYmluZChuZXh0X29iaikoaXRbMF0sIGl0WzFdKVxuICAgICAgICAgICAgICAgICkubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNfZHVwbGljYXRlKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2gobmV4dF9vYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VTdGFjayhzdGFjaywgbGVuZ3RoKSB7XG4gICAgLyogR2l2ZW4gYSBsaXN0IG9mIGxpc3RzIG9mIG9iamVjdHMgKHdoaWNoIGZvciBicmV2aXR5IHdlIGNhbGwgYSBzdGFjayksXG4gICAgICogcmV0dXJuIGEgbGlzdCBvZiBvYmplY3RzIHdoZXJlIGVhY2ggb2JqZWN0IGlzIHRoZSBtZXJnZSBvZiBhbGwgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyBvcmlnaW5hbCBvYmplY3RzIGF0IHRoYXQgcGFydGljdWxhciBpbmRleC5cbiAgICAgKlxuICAgICAqIElmIGEgY2VydGFpbiBzdWItbGlzdCBkb2Vzbid0IGhhdmUgYW4gb2JqZWN0IGF0IHRoYXQgcGFydGljdWxhclxuICAgICAqIGluZGV4LCB0aGUgbGFzdCBvYmplY3QgaW4gdGhhdCBsaXN0IGlzIG1lcmdlZC5cbiAgICAgKi9cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRzLnB1c2goe30pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIHN0YWNrKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lX2xlbmd0aCA9IGZyYW1lLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdHNbeF0gPSAkLmV4dGVuZChcbiAgICAgICAgICAgICAgICByZXN1bHRzW3hdIHx8IHt9LFxuICAgICAgICAgICAgICAgIGZyYW1lW3ggPiBmcmFtZV9sZW5ndGggPyBmcmFtZV9sZW5ndGggOiB4XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50SW5WaWV3cG9ydChlbCwgcGFydGlhbCA9IGZhbHNlLCBvZmZzZXQgPSAwKSB7XG4gICAgLyogcmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgaXMgdmlzaWJsZSB0byB0aGUgdXNlciBpZS4gaXMgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqIFNldHRpbmcgcGFydGlhbCBwYXJhbWV0ZXIgdG8gdHJ1ZSwgd2lsbCBvbmx5IGNoZWNrIGlmIGEgcGFydCBvZiB0aGUgZWxlbWVudCBpcyB2aXNpYmxlXG4gICAgICogaW4gdGhlIHZpZXdwb3J0LCBzcGVjaWZpY2FsbHkgdGhhdCBzb21lIHBhcnQgb2YgdGhhdCBlbGVtZW50IGlzIHRvdWNoaW5nIHRoZSB0b3AgcGFydFxuICAgICAqIG9mIHRoZSB2aWV3cG9ydC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbiwgaWUuIGRvZXNudCBjaGVjayBwYXJ0aWFsXG4gICAgICogdmlzaWJpbGl0eSBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmdcbiAgICAgKiBzb21lIGNvZGUgdGFrZW4gZnJvbTpcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyMzk5OS9ob3ctdG8tdGVsbC1pZi1hLWRvbS1lbGVtZW50LWlzLXZpc2libGUtaW4tdGhlLWN1cnJlbnQtdmlld3BvcnQvNzU1NzQzMyM3NTU3NDMzXG4gICAgICovXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgJCkge1xuICAgICAgICBlbCA9IGVsWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHJlY192YWx1ZXMgPSBbcmVjLnRvcCwgcmVjLmJvdHRvbSwgcmVjLmxlZnQsIHJlYy5yaWdodF07XG5cbiAgICBpZiAocmVjX3ZhbHVlcy5ldmVyeSgodmFsKSA9PiB2YWwgPT09IDApKSB7XG4gICAgICAgIC8vIGlmIGV2ZXJ5IHByb3BlcnR5IG9mIHJlYyBpcyAwLCB0aGUgZWxlbWVudCBpcyBpbnZpc2libGU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgLy8gd2hlbiB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSAoaW4gdGhlIHZlcnRpY2FsIGNhc2UpXG4gICAgICAgIC8vIG5lZ2F0aXZlIG1lYW5zIGFib3ZlIHRvcCBvZiB2aWV3cG9ydCwgcG9zaXRpdmUgbWVhbnMgYmVsb3cgdG9wIG9mIHZpZXdwb3J0XG4gICAgICAgIC8vIHRoZXJlZm9yZSBmb3IgcGFydCBvZiB0aGUgZWxlbWVudCB0byBiZSB0b3VjaGluZyBvciBjcm9zc2luZyB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICAvLyByZWMudG9wIG11c3QgPD0gMCBhbmQgcmVjLmJvdHRvbSBtdXN0ID49IDBcbiAgICAgICAgLy8gYW4gb3B0aW9uYWwgdG9sZXJhbmNlIG9mZnNldCBjYW4gYmUgYWRkZWQgZm9yIHdoZW4gdGhlIGRlc2lyZWQgZWxlbWVudCBpcyBub3QgZXhhY3RseVxuICAgICAgICAvLyB0b3VjaW5nIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IGJ1dCBuZWVkcyB0byBiZSBjb25zaWRlcmVkIGFzIHRvdWNoaW5nLlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVjLnRvcCA8PSAwICsgb2Zmc2V0ICYmIHJlYy5ib3R0b20gPj0gMCArIG9mZnNldFxuICAgICAgICAgICAgLy8ocmVjLnRvcCA+PSAwK29mZnNldCAmJiByZWMudG9wIDw9IHdpbmRvdy5pbm5lckhlaWdodCkgLy8gdGhpcyBjaGVja3MgaWYgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRvdWNoZXMgYm90dG9tIHBhcnQgb2Ygdmlld3BvcnRcbiAgICAgICAgICAgIC8vIFhYWCBkbyB3ZSB3YW50IHRvIGluY2x1ZGUgYSBjaGVjayBmb3IgdGhlIHBhZGRpbmcgb2YgYW4gZWxlbWVudD9cbiAgICAgICAgICAgIC8vIHVzaW5nIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkucGFkZGluZ1RvcFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgZW50aXJlIGVsZW1lbnQgaXMgY29tcGxldGVseSBpbiB0aGUgdmlld3BvcnRcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlYy50b3AgPj0gMCAmJlxuICAgICAgICAgICAgcmVjLmxlZnQgPj0gMCAmJlxuICAgICAgICAgICAgcmVjLmJvdHRvbSA8PVxuICAgICAgICAgICAgICAgICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgJiZcbiAgICAgICAgICAgIHJlYy5yaWdodCA8PSAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKVxuICAgICAgICApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lKHRpbWUpIHtcbiAgICB2YXIgbSA9IC9eKFxcZCsoPzpcXC5cXGQrKT8pXFxzKihcXHcqKS8uZXhlYyh0aW1lKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0aW1lXCIpO1xuICAgIH1cbiAgICB2YXIgYW1vdW50ID0gcGFyc2VGbG9hdChtWzFdKTtcbiAgICBzd2l0Y2ggKG1bMl0pIHtcbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGFtb3VudCAqIDEwMDApO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYW1vdW50ICogMTAwMCAqIDYwKTtcbiAgICAgICAgY2FzZSBcIm1zXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhbW91bnQpO1xuICAgIH1cbn1cblxuLy8gUmV0dXJuIGEgalF1ZXJ5IG9iamVjdCB3aXRoIGVsZW1lbnRzIHJlbGF0ZWQgdG8gYW4gaW5wdXQgZWxlbWVudC5cbmZ1bmN0aW9uIGZpbmRSZWxhdGl2ZXMoZWwpIHtcbiAgICB2YXIgJGVsID0gJChlbCksXG4gICAgICAgICRyZWxhdGl2ZXMgPSAkKGVsKSxcbiAgICAgICAgJGxhYmVsID0gJCgpO1xuXG4gICAgJHJlbGF0aXZlcyA9ICRyZWxhdGl2ZXMuYWRkKCRlbC5jbG9zZXN0KFwibGFiZWxcIikpO1xuICAgICRyZWxhdGl2ZXMgPSAkcmVsYXRpdmVzLmFkZCgkZWwuY2xvc2VzdChcImZpZWxkc2V0XCIpKTtcblxuICAgIGlmIChlbC5pZCkgJGxhYmVsID0gJChcImxhYmVsW2Zvcj0nXCIgKyBlbC5pZCArIFwiJ11cIik7XG4gICAgaWYgKCEkbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgIHZhciAkZm9ybSA9ICRlbC5jbG9zZXN0KFwiZm9ybVwiKTtcbiAgICAgICAgaWYgKCEkZm9ybS5sZW5ndGgpICRmb3JtID0gJChkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgJGxhYmVsID0gJGZvcm0uZmluZChcImxhYmVsW2Zvcj0nXCIgKyBlbC5uYW1lICsgXCInXVwiKTtcbiAgICB9XG4gICAgJHJlbGF0aXZlcyA9ICRyZWxhdGl2ZXMuYWRkKCRsYWJlbCk7XG4gICAgcmV0dXJuICRyZWxhdGl2ZXM7XG59XG5cbmZ1bmN0aW9uIGdldF9ib3VuZHMoZWwpIHtcbiAgICAvLyBSZXR1cm4gYm91bmRzIG9mIGFuIGVsZW1lbnQgd2l0aCBpdCdzIHZhbHVlcyByb3VuZGVkIGFuZCBjb252ZXJ0ZWQgdG8gaW50cy5cbiAgICBjb25zdCBib3VuZHMgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBwYXJzZUludChNYXRoLnJvdW5kKGJvdW5kcy54KSwgMTApIHx8IDAsXG4gICAgICAgIHk6IHBhcnNlSW50KE1hdGgucm91bmQoYm91bmRzLnkpLCAxMCkgfHwgMCxcbiAgICAgICAgdG9wOiBwYXJzZUludChNYXRoLnJvdW5kKGJvdW5kcy50b3ApLCAxMCkgfHwgMCxcbiAgICAgICAgYm90dG9tOiBwYXJzZUludChNYXRoLnJvdW5kKGJvdW5kcy5ib3R0b20pLCAxMCkgfHwgMCxcbiAgICAgICAgbGVmdDogcGFyc2VJbnQoTWF0aC5yb3VuZChib3VuZHMubGVmdCksIDEwKSB8fCAwLFxuICAgICAgICByaWdodDogcGFyc2VJbnQoTWF0aC5yb3VuZChib3VuZHMucmlnaHQpLCAxMCkgfHwgMCxcbiAgICAgICAgd2lkdGg6IHBhcnNlSW50KE1hdGgucm91bmQoYm91bmRzLndpZHRoKSwgMTApIHx8IDAsXG4gICAgICAgIGhlaWdodDogcGFyc2VJbnQoTWF0aC5yb3VuZChib3VuZHMuaGVpZ2h0KSwgMTApIHx8IDAsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnB1dFN1cHBvcnQodHlwZSwgaW52YWxpZF92YWx1ZSkge1xuICAgIC8qIENoZWNrIGlucHV0IHR5cGUgc3VwcG9ydC5cbiAgICAgKiAgU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTAxOTkzMDYvMTMzNzQ3NFxuICAgICAqL1xuICAgIGxldCBzdXBwb3J0ID0gZmFsc2U7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCB0eXBlKTtcbiAgICBzdXBwb3J0ID0gaW5wdXQudHlwZSA9PSB0eXBlO1xuXG4gICAgaWYgKGludmFsaWRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgaW5wdXQgdHlwZSBVSSBzdXBwb3J0XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIGludmFsaWRfdmFsdWUpO1xuICAgICAgICBzdXBwb3J0ID0gaW5wdXQudmFsdWUgIT09IGludmFsaWRfdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0O1xufVxuXG5jb25zdCBjaGVja0NTU0ZlYXR1cmUgPSAoYXR0cmlidXRlLCB2YWx1ZSwgdGFnID0gXCJkaXZcIikgPT4ge1xuICAgIC8qIENoZWNrIGZvciBicm93c2VyIHN1cHBvcnQgb2Ygc3BlY2lmaWMgQ1NTIGZlYXR1cmUuXG4gICAgICovXG4gICAgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGxldCBzdXBwb3J0ZWQgPSB0YWcuc3R5bGVbYXR0cmlidXRlXSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChzdXBwb3J0ZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YWcuc3R5bGVbYXR0cmlidXRlXSA9IHZhbHVlO1xuICAgICAgICBzdXBwb3J0ZWQgPSB0YWcuc3R5bGVbYXR0cmlidXRlXSA9PT0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG59O1xuXG5jb25zdCBhbmltYXRpb25fZnJhbWUgPSAoKSA9PiB7XG4gICAgLy8gUmV0dXJuIHByb21pc2UgdG8gYXdhaXQgbmV4dCByZXBhaW50IGN5Y2xlXG4gICAgLy8gVXNlIGl0IGluIHlvdXIgYXN5bmMgZnVuY3Rpb24gbGlrZSBzbzogYGBhd2FpdCB1dGlscy5hbmltYXRpb25fZnJhbWUoKWBgXG4gICAgLy8gRnJvbTogaHR0cDovL3d3dy5hbGJlcnRsb2JvLmNvbS9mcmFjdGFscy9hc3luYy1hd2FpdC1yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtYnVkZGhhYnJvdFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcbn07XG5cbmNvbnN0IHRpbWVvdXQgPSAobXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn07XG5cbmNvbnN0IGRlYm91bmNlID0gKGZ1bmMsIG1zLCB0aW1lciA9IHsgdGltZXI6IG51bGwgfSkgPT4ge1xuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gICAgLy8gTiBtaWxsaXNlY29uZHMuXG4gICAgLy8gRnJvbTogaHR0cHM6Ly91bmRlcnNjb3JlanMub3JnLyNkZWJvdW5jZVxuICAgIC8vXG4gICAgLy8gTWFrZSBzdXJlIHRvIGluaXRpYWxpemUgYGBkZWJvdW5jZWBgIG9ubHkgb25jZSBwZXIgdG8tYmUtZGVib3VuY2VkXG4gICAgLy8gZnVuY3Rpb24gdG8gbm90IHJlaW5pdGlhbGl6ZSB0aGUgdGltZXIgZWFjaCB0aW1lIGFuZCBkZWJvdW5jZSBub3QgYmVpbmdcbiAgICAvLyBhYmxlIHRvIGNhbmNlbCBwcmV2aW91c2UgcnVucy5cbiAgICAvL1xuICAgIC8vIFBhc3MgYSBtb2R1bGUtZ2xvYmFsIHRpbWVyIGFzIGFuIG9iamVjdCBgYHsgdGltZXI6IG51bGwgfWBgIGlmIHlvdSB3YW50XG4gICAgLy8gdG8gYWxzbyBjYW5jZWwgZGVib3VuY2VkIGZ1bmN0aW9ucyBmcm9tIG90aGVyIHBhdHRlcm4taW52b2NhdGlvbnMuXG4gICAgLy9cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB0aW1lci50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKSwgbXMpO1xuICAgIH07XG59O1xuXG5jb25zdCBpc0lFID0gKCkgPT4ge1xuICAgIC8vIFNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk4NTE3NjkvMTMzNzQ3NFxuICAgIC8vIEludGVybmV0IEV4cGxvcmVyIDYtMTFcbiAgICByZXR1cm4gLypAY2Nfb24hQCovIGZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufTtcblxuY29uc3QganFUb05vZGUgPSAoZWwpID0+IHtcbiAgICAvLyBSZXR1cm4gYSBET00gbm9kZSBpZiBhIGpRdWVyeSBub2RlIHdhcyBwYXNzZWQuXG4gICAgaWYgKGVsLmpxdWVyeSkge1xuICAgICAgICBlbCA9IGVsWzBdO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG59O1xuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gYW4gaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7YW55fSBpdDogVGhlIG9iamVjdCB3aGljaCBuZWVkcyB0byBiZSB3cmFwcGVkIGluIGFuIGFycmF5IG9yIHJldHVybmVkIGFzIGlzIGlmIGl0IGlzIGl0ZXJhYmxlLlxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZV9hcnJheTogSWYgdGhlIG9iamVjdCBpcyBpdGVyYWJsZSBidXQgbm90IGFuIEFycmF5LCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IChlLmcuIEZvciBqUXVlcnkgaXRlbXMgb3IgTm9kZUxpc3Qgb2JqZWN0cykuXG4gKlxuICogQHJldHVybnMge0FycmF5fTogUmV0dXJucyB0aGUgb2JqZWN0IHdyYXBwZWQgaW4gYW4gQXJyYXksIGV4cGFuZGVkIHRvIGFuIEFycmF5IG9yIGFzLWlzIGlmIGl0IGlzIGFscmVhZHkgaXRlcmFibGUuXG4gKi9cbmNvbnN0IGVuc3VyZUFycmF5ID0gKGl0LCBmb3JjZV9hcnJheSkgPT4ge1xuICAgIC8vIEVuc3VyZSB0byByZXR1cm4gYWx3YXlzIGFuIGFycmF5XG4gICAgY29uc3QgYXJyYXlfbGlrZSA9ICEhKFxuICAgICAgICBOb2RlTGlzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpdCkgfHwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgQXJyYXkuaXNBcnJheShpdCkgfHxcbiAgICAgICAgaXQuanF1ZXJ5XG4gICAgKTtcbiAgICByZXR1cm4gYXJyYXlfbGlrZSA/IChmb3JjZV9hcnJheSA/IFsuLi5pdF0gOiBpdCkgOiBbaXRdO1xufTtcblxuY29uc3QgbG9jYWxpemVkX2lzb2RhdGUgPSAoZGF0ZSkgPT4ge1xuICAgIC8vIFJldHVybiBhIGlzbyBkYXRlIChkYXRlIG9ubHkpIGluIHRoZSBjdXJyZW50IHRpbWV6b25lIGluc3RlYWQgb2YgYVxuICAgIC8vIFVUQyBJU08gODYwMSBkYXRlK3RpbWUgY29tcG9uZW50IHdoaWNoIHRvSVNPU3RyaW5nIHJldHVybnMuXG5cbiAgICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICBjb25zdCBtb250aCA9IChkYXRlLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG5cbiAgICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbn07XG5cbi8qKlxuICogUmVwbGFjZSBIVE1MIHJlc2VydmVkIGNoYXJhY3RlcnMgd2l0aCBodG1sIGVudGl0aWVzIHRvIGFkZCBIVE1MIGZvciB1c2VyXG4gKiBlZGl0aW5nIHRvIGUuZy4gYSB0ZXh0YXJlYSBvciBhIGNvbnRlbnRlZGl0YWJsZS5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvRW50aXR5I3Jlc2VydmVkX2NoYXJhY3RlcnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbCAtIFRoZSBIVE1MIHN0cmluZyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gLSBSZXR1cm5zIHRoZSBlc2NhcGVkIGh0bWwgc3RyaW5nOlxuICogICAgICAgICAgICAgICAgICAgICBgYCZgYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYGAmYW1wO2BgLlxuICogICAgICAgICAgICAgICAgICAgICBgYDxgYCB3aWxsIGJlIHJlcGFsY2VkIHdpdGggYGAmbHQ7YGAsXG4gKiAgICAgICAgICAgICAgICAgICAgIGBgPmBgIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBgYCZndDtgYCxcbiAqICAgICAgICAgICAgICAgICAgICAgYGBcImBgIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBgYCZxdW90O2BgLlxuICovXG5jb25zdCBlc2NhcGVfaHRtbCA9IChodG1sKSA9PiB7XG4gICAgcmV0dXJuIChodG1sIHx8IFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikgLy8gbmVlZHMgdG8gYmUgZmlyc3QhXG4gICAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdW5lc2NhcGVkLCByYXcgSFRNTCBmcm9tIGFuIGVzY2FwZWQgSFRNTCAgc3RyaW5nLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9HbG9zc2FyeS9FbnRpdHkjcmVzZXJ2ZWRfY2hhcmFjdGVyc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlc2NhcGVkX2h0bWwgLSBUaGUgSFRNTCBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gUmV0dXJucyB0aGUgZXNjYXBlZCBodG1sIHN0cmluZzpcbiAqICAgICAgICAgICAgICAgICAgICAgYGAmYW1wO2BgIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBgYCZgYCxcbiAqICAgICAgICAgICAgICAgICAgICAgYGAmbHQ7YGAgd2lsbCBiZSByZXBhbGNlZCB3aXRoIGBgPGBgLFxuICogICAgICAgICAgICAgICAgICAgICBgYCZndDtgYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYGA+YGAsXG4gKiAgICAgICAgICAgICAgICAgICAgIGBgJnF1b3Q7YGAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGBgXCJgYC5cbiAqL1xuY29uc3QgdW5lc2NhcGVfaHRtbCA9IChlc2NhcGVkX2h0bWwpID0+IHtcbiAgICByZXR1cm4gKGVzY2FwZWRfaHRtbCB8fCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvJmFtcDsvZywgXCImXCIpXG4gICAgICAgIC5yZXBsYWNlKC8mbHQ7L2csIFwiPFwiKVxuICAgICAgICAucmVwbGFjZSgvJmd0Oy9nLCBcIj5cIilcbiAgICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUsIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIElTTyA4NjAxIGRhdGUvdGltZSBzdHJpbmcgd2l0aCBvciB3aXRob3V0IGFuIG9wdGlvbmFsIHRpbWUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIFRoZSBkYXRlL3RpbWUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbmFsX3RpbWU9ZmFsc2VdIC0gVHJ1ZSwgaWYgdGltZSBjb21wb25lbnQgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIFRydWUsIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIERhdGUgc3RyaW5nLiBGYWxzZSBpZiBub3QuXG4gKi9cbmNvbnN0IGlzX2lzb19kYXRlX3RpbWUgPSAodmFsdWUsIG9wdGlvbmFsX3RpbWUgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHJlX2RhdGVfdGltZSA9IG9wdGlvbmFsX3RpbWVcbiAgICAgICAgPyAvXlxcZHs0fS1bMDFdXFxkLVswLTNdXFxkKFRbMC0yXVxcZDpbMC01XVxcZCk/JC9cbiAgICAgICAgOiAvXlxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkJC87XG4gICAgcmV0dXJuIHJlX2RhdGVfdGltZS50ZXN0KHZhbHVlKTtcbn07XG5cbnZhciB1dGlscyA9IHtcbiAgICAvLyBwYXR0ZXJuIHBpbXBpbmcgLSBvd24gbW9kdWxlP1xuICAgIGpxdWVyeVBsdWdpbjoganF1ZXJ5UGx1Z2luLFxuICAgIGVzY2FwZVJlZ0V4cDogZXNjYXBlUmVnRXhwLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICByZWJhc2VVUkw6IHJlYmFzZVVSTCxcbiAgICBmaW5kTGFiZWw6IGZpbmRMYWJlbCxcbiAgICBlbGVtZW50SW5WaWV3cG9ydDogZWxlbWVudEluVmlld3BvcnQsXG4gICAgcmVtb3ZlV2lsZGNhcmRDbGFzczogcmVtb3ZlV2lsZGNhcmRDbGFzcyxcbiAgICBoaWRlT3JTaG93OiBoaWRlT3JTaG93LFxuICAgIGFkZFVSTFF1ZXJ5UGFyYW1ldGVyOiBhZGRVUkxRdWVyeVBhcmFtZXRlcixcbiAgICByZW1vdmVEdXBsaWNhdGVPYmplY3RzOiByZW1vdmVEdXBsaWNhdGVPYmplY3RzLFxuICAgIG1lcmdlU3RhY2s6IG1lcmdlU3RhY2ssXG4gICAgaXNFbGVtZW50SW5WaWV3cG9ydDogaXNFbGVtZW50SW5WaWV3cG9ydCxcbiAgICBoYXNWYWx1ZTogaGFzVmFsdWUsXG4gICAgcGFyc2VUaW1lOiBwYXJzZVRpbWUsXG4gICAgZmluZFJlbGF0aXZlczogZmluZFJlbGF0aXZlcyxcbiAgICBnZXRfYm91bmRzOiBnZXRfYm91bmRzLFxuICAgIGNoZWNrSW5wdXRTdXBwb3J0OiBjaGVja0lucHV0U3VwcG9ydCxcbiAgICBjaGVja0NTU0ZlYXR1cmU6IGNoZWNrQ1NTRmVhdHVyZSxcbiAgICBhbmltYXRpb25fZnJhbWU6IGFuaW1hdGlvbl9mcmFtZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIGRlYm91bmNlOiBkZWJvdW5jZSxcbiAgICBpc0lFOiBpc0lFLFxuICAgIGpxVG9Ob2RlOiBqcVRvTm9kZSxcbiAgICBlbnN1cmVBcnJheTogZW5zdXJlQXJyYXksXG4gICAgbG9jYWxpemVkX2lzb2RhdGU6IGxvY2FsaXplZF9pc29kYXRlLFxuICAgIGVzY2FwZV9odG1sOiBlc2NhcGVfaHRtbCxcbiAgICB1bmVzY2FwZV9odG1sOiB1bmVzY2FwZV9odG1sLFxuICAgIGlzX2lzb19kYXRlX3RpbWU6IGlzX2lzb19kYXRlX3RpbWUsXG4gICAgZ2V0Q1NTVmFsdWU6IGRvbS5nZXRfY3NzX3ZhbHVlLCAvLyBCQkI6IG1vdmVkIHRvIGRvbS4gVE9ETzogUmVtb3ZlIGluIHVwY29taW5nIHZlcnNpb24uXG59O1xuXG5leHBvcnQgZGVmYXVsdCB1dGlscztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gcnVudGltZSBoZWxwZXIgZm9yIHNldHRpbmcgcHJvcGVydGllcyBvbiBjb21wb25lbnRzXG4vLyBpbiBhIHRyZWUtc2hha2FibGUgd2F5XG5leHBvcnRzLmRlZmF1bHQgPSAoc2ZjLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IHNmYy5fX3ZjY09wdHMgfHwgc2ZjO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBwcm9wcykge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=